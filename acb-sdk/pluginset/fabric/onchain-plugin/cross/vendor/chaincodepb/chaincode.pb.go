// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: chaincode.proto

package chaincodepb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// ---------------------------------- Oracle ------------------------------------------
//
// Oracle basic info
type OracleBasicInfo struct {
	OracleHashId         []byte   `protobuf:"bytes,1,opt,name=oracle_hash_id,json=oracleHashId,proto3" json:"oracle_hash_id,omitempty"`
	OracleBizId          string   `protobuf:"bytes,2,opt,name=oracle_biz_id,json=oracleBizId,proto3" json:"oracle_biz_id,omitempty"`
	OracleName           string   `protobuf:"bytes,3,opt,name=oracle_name,json=oracleName,proto3" json:"oracle_name,omitempty"`
	OracleDesc           string   `protobuf:"bytes,4,opt,name=oracle_desc,json=oracleDesc,proto3" json:"oracle_desc,omitempty"`
	TotalNodeNum         uint32   `protobuf:"varint,5,opt,name=total_node_num,json=totalNodeNum,proto3" json:"total_node_num,omitempty"`
	IfExists             bool     `protobuf:"varint,6,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OracleBasicInfo) Reset()         { *m = OracleBasicInfo{} }
func (m *OracleBasicInfo) String() string { return proto.CompactTextString(m) }
func (*OracleBasicInfo) ProtoMessage()    {}
func (*OracleBasicInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{0}
}
func (m *OracleBasicInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleBasicInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OracleBasicInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleBasicInfo.Merge(m, src)
}
func (m *OracleBasicInfo) XXX_Size() int {
	return m.Size()
}
func (m *OracleBasicInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleBasicInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OracleBasicInfo proto.InternalMessageInfo

func (m *OracleBasicInfo) GetOracleHashId() []byte {
	if m != nil {
		return m.OracleHashId
	}
	return nil
}

func (m *OracleBasicInfo) GetOracleBizId() string {
	if m != nil {
		return m.OracleBizId
	}
	return ""
}

func (m *OracleBasicInfo) GetOracleName() string {
	if m != nil {
		return m.OracleName
	}
	return ""
}

func (m *OracleBasicInfo) GetOracleDesc() string {
	if m != nil {
		return m.OracleDesc
	}
	return ""
}

func (m *OracleBasicInfo) GetTotalNodeNum() uint32 {
	if m != nil {
		return m.TotalNodeNum
	}
	return 0
}

func (m *OracleBasicInfo) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

// SGX trust root, trusted setup by contract admin
type SGXTrustRoot struct {
	// ias desc
	IasDesc string `protobuf:"bytes,1,opt,name=ias_desc,json=iasDesc,proto3" json:"ias_desc,omitempty"`
	// ias public key
	IasPubKey string `protobuf:"bytes,2,opt,name=ias_pub_key,json=iasPubKey,proto3" json:"ias_pub_key,omitempty"`
	// ias root ca
	RootCa string `protobuf:"bytes,3,opt,name=root_ca,json=rootCa,proto3" json:"root_ca,omitempty"`
	// Oracle SGX's mrenclave
	MrEnclave []byte `protobuf:"bytes,4,opt,name=mr_enclave,json=mrEnclave,proto3" json:"mr_enclave,omitempty"`
	// if psw module support
	IfPswSupport         bool     `protobuf:"varint,5,opt,name=if_psw_support,json=ifPswSupport,proto3" json:"if_psw_support,omitempty"`
	IfExists             bool     `protobuf:"varint,6,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SGXTrustRoot) Reset()         { *m = SGXTrustRoot{} }
func (m *SGXTrustRoot) String() string { return proto.CompactTextString(m) }
func (*SGXTrustRoot) ProtoMessage()    {}
func (*SGXTrustRoot) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{1}
}
func (m *SGXTrustRoot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SGXTrustRoot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SGXTrustRoot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SGXTrustRoot.Merge(m, src)
}
func (m *SGXTrustRoot) XXX_Size() int {
	return m.Size()
}
func (m *SGXTrustRoot) XXX_DiscardUnknown() {
	xxx_messageInfo_SGXTrustRoot.DiscardUnknown(m)
}

var xxx_messageInfo_SGXTrustRoot proto.InternalMessageInfo

func (m *SGXTrustRoot) GetIasDesc() string {
	if m != nil {
		return m.IasDesc
	}
	return ""
}

func (m *SGXTrustRoot) GetIasPubKey() string {
	if m != nil {
		return m.IasPubKey
	}
	return ""
}

func (m *SGXTrustRoot) GetRootCa() string {
	if m != nil {
		return m.RootCa
	}
	return ""
}

func (m *SGXTrustRoot) GetMrEnclave() []byte {
	if m != nil {
		return m.MrEnclave
	}
	return nil
}

func (m *SGXTrustRoot) GetIfPswSupport() bool {
	if m != nil {
		return m.IfPswSupport
	}
	return false
}

func (m *SGXTrustRoot) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

// Oracle node entity basic info
type OracleNodeBasicInfo struct {
	NodeHashId []byte `protobuf:"bytes,1,opt,name=node_hash_id,json=nodeHashId,proto3" json:"node_hash_id,omitempty"`
	NodeBizId  string `protobuf:"bytes,2,opt,name=node_biz_id,json=nodeBizId,proto3" json:"node_biz_id,omitempty"`
	NodeName   string `protobuf:"bytes,3,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	NodeDesc   string `protobuf:"bytes,4,opt,name=node_desc,json=nodeDesc,proto3" json:"node_desc,omitempty"`
	// oracle node master keys
	RsaPubKey   []byte `protobuf:"bytes,5,opt,name=rsa_pub_key,json=rsaPubKey,proto3" json:"rsa_pub_key,omitempty"`
	EcdsaPubKey []byte `protobuf:"bytes,6,opt,name=ecdsa_pub_key,json=ecdsaPubKey,proto3" json:"ecdsa_pub_key,omitempty"`
	// if monotonic counter support
	CounterFlag          uint32   `protobuf:"varint,7,opt,name=counter_flag,json=counterFlag,proto3" json:"counter_flag,omitempty"`
	CounterIdHash        []byte   `protobuf:"bytes,8,opt,name=counter_id_hash,json=counterIdHash,proto3" json:"counter_id_hash,omitempty"`
	CounterValue         uint32   `protobuf:"varint,9,opt,name=counter_value,json=counterValue,proto3" json:"counter_value,omitempty"`
	VerifyTimestamp      uint32   `protobuf:"varint,10,opt,name=verify_timestamp,json=verifyTimestamp,proto3" json:"verify_timestamp,omitempty"`
	IfExists             bool     `protobuf:"varint,11,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OracleNodeBasicInfo) Reset()         { *m = OracleNodeBasicInfo{} }
func (m *OracleNodeBasicInfo) String() string { return proto.CompactTextString(m) }
func (*OracleNodeBasicInfo) ProtoMessage()    {}
func (*OracleNodeBasicInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{2}
}
func (m *OracleNodeBasicInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleNodeBasicInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OracleNodeBasicInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleNodeBasicInfo.Merge(m, src)
}
func (m *OracleNodeBasicInfo) XXX_Size() int {
	return m.Size()
}
func (m *OracleNodeBasicInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleNodeBasicInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OracleNodeBasicInfo proto.InternalMessageInfo

func (m *OracleNodeBasicInfo) GetNodeHashId() []byte {
	if m != nil {
		return m.NodeHashId
	}
	return nil
}

func (m *OracleNodeBasicInfo) GetNodeBizId() string {
	if m != nil {
		return m.NodeBizId
	}
	return ""
}

func (m *OracleNodeBasicInfo) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *OracleNodeBasicInfo) GetNodeDesc() string {
	if m != nil {
		return m.NodeDesc
	}
	return ""
}

func (m *OracleNodeBasicInfo) GetRsaPubKey() []byte {
	if m != nil {
		return m.RsaPubKey
	}
	return nil
}

func (m *OracleNodeBasicInfo) GetEcdsaPubKey() []byte {
	if m != nil {
		return m.EcdsaPubKey
	}
	return nil
}

func (m *OracleNodeBasicInfo) GetCounterFlag() uint32 {
	if m != nil {
		return m.CounterFlag
	}
	return 0
}

func (m *OracleNodeBasicInfo) GetCounterIdHash() []byte {
	if m != nil {
		return m.CounterIdHash
	}
	return nil
}

func (m *OracleNodeBasicInfo) GetCounterValue() uint32 {
	if m != nil {
		return m.CounterValue
	}
	return 0
}

func (m *OracleNodeBasicInfo) GetVerifyTimestamp() uint32 {
	if m != nil {
		return m.VerifyTimestamp
	}
	return 0
}

func (m *OracleNodeBasicInfo) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

type SGXProof struct {
	AVR                  string   `protobuf:"bytes,1,opt,name=AVR,proto3" json:"AVR,omitempty"`
	AVRSig               string   `protobuf:"bytes,2,opt,name=AVR_sig,json=AVRSig,proto3" json:"AVR_sig,omitempty"`
	IasCertChain         string   `protobuf:"bytes,3,opt,name=ias_cert_chain,json=iasCertChain,proto3" json:"ias_cert_chain,omitempty"`
	RaData               string   `protobuf:"bytes,4,opt,name=ra_data,json=raData,proto3" json:"ra_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SGXProof) Reset()         { *m = SGXProof{} }
func (m *SGXProof) String() string { return proto.CompactTextString(m) }
func (*SGXProof) ProtoMessage()    {}
func (*SGXProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{3}
}
func (m *SGXProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SGXProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SGXProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SGXProof.Merge(m, src)
}
func (m *SGXProof) XXX_Size() int {
	return m.Size()
}
func (m *SGXProof) XXX_DiscardUnknown() {
	xxx_messageInfo_SGXProof.DiscardUnknown(m)
}

var xxx_messageInfo_SGXProof proto.InternalMessageInfo

func (m *SGXProof) GetAVR() string {
	if m != nil {
		return m.AVR
	}
	return ""
}

func (m *SGXProof) GetAVRSig() string {
	if m != nil {
		return m.AVRSig
	}
	return ""
}

func (m *SGXProof) GetIasCertChain() string {
	if m != nil {
		return m.IasCertChain
	}
	return ""
}

func (m *SGXProof) GetRaData() string {
	if m != nil {
		return m.RaData
	}
	return ""
}

// UDNSDomainInfo represents unds for an specified domain
type UDNSDomainInfo struct {
	// domain basic info
	DomainHashId []byte `protobuf:"bytes,1,opt,name=domain_hash_id,json=domainHashId,proto3" json:"domain_hash_id,omitempty"`
	DomainName   string `protobuf:"bytes,2,opt,name=domain_name,json=domainName,proto3" json:"domain_name,omitempty"`
	// udns domain cert
	UdnsCert   []byte `protobuf:"bytes,3,opt,name=udns_cert,json=udnsCert,proto3" json:"udns_cert,omitempty"`
	DomainCert []byte `protobuf:"bytes,4,opt,name=domain_cert,json=domainCert,proto3" json:"domain_cert,omitempty"`
	// udns domain public keys
	UdnsRsaPubKey   []byte `protobuf:"bytes,5,opt,name=udns_rsa_pub_key,json=udnsRsaPubKey,proto3" json:"udns_rsa_pub_key,omitempty"`
	UdnsEcdsaPubKey []byte `protobuf:"bytes,6,opt,name=udns_ecdsa_pub_key,json=udnsEcdsaPubKey,proto3" json:"udns_ecdsa_pub_key,omitempty"`
	// tlv data {version|domain_cert|udns_cert|domain_name|pk}
	SigningBody []byte `protobuf:"bytes,7,opt,name=signing_body,json=signingBody,proto3" json:"signing_body,omitempty"`
	// oracle master key hash
	PubKeyHash []byte `protobuf:"bytes,8,opt,name=pub_key_hash,json=pubKeyHash,proto3" json:"pub_key_hash,omitempty"`
	// signature by oracle master key
	Sig                  []byte   `protobuf:"bytes,9,opt,name=sig,proto3" json:"sig,omitempty"`
	VerifyTimestamp      uint32   `protobuf:"varint,10,opt,name=verify_timestamp,json=verifyTimestamp,proto3" json:"verify_timestamp,omitempty"`
	IfExists             bool     `protobuf:"varint,11,opt,name=if_exists,json=ifExists,proto3" json:"if_exists,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UDNSDomainInfo) Reset()         { *m = UDNSDomainInfo{} }
func (m *UDNSDomainInfo) String() string { return proto.CompactTextString(m) }
func (*UDNSDomainInfo) ProtoMessage()    {}
func (*UDNSDomainInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{4}
}
func (m *UDNSDomainInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UDNSDomainInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UDNSDomainInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UDNSDomainInfo.Merge(m, src)
}
func (m *UDNSDomainInfo) XXX_Size() int {
	return m.Size()
}
func (m *UDNSDomainInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UDNSDomainInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UDNSDomainInfo proto.InternalMessageInfo

func (m *UDNSDomainInfo) GetDomainHashId() []byte {
	if m != nil {
		return m.DomainHashId
	}
	return nil
}

func (m *UDNSDomainInfo) GetDomainName() string {
	if m != nil {
		return m.DomainName
	}
	return ""
}

func (m *UDNSDomainInfo) GetUdnsCert() []byte {
	if m != nil {
		return m.UdnsCert
	}
	return nil
}

func (m *UDNSDomainInfo) GetDomainCert() []byte {
	if m != nil {
		return m.DomainCert
	}
	return nil
}

func (m *UDNSDomainInfo) GetUdnsRsaPubKey() []byte {
	if m != nil {
		return m.UdnsRsaPubKey
	}
	return nil
}

func (m *UDNSDomainInfo) GetUdnsEcdsaPubKey() []byte {
	if m != nil {
		return m.UdnsEcdsaPubKey
	}
	return nil
}

func (m *UDNSDomainInfo) GetSigningBody() []byte {
	if m != nil {
		return m.SigningBody
	}
	return nil
}

func (m *UDNSDomainInfo) GetPubKeyHash() []byte {
	if m != nil {
		return m.PubKeyHash
	}
	return nil
}

func (m *UDNSDomainInfo) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *UDNSDomainInfo) GetVerifyTimestamp() uint32 {
	if m != nil {
		return m.VerifyTimestamp
	}
	return 0
}

func (m *UDNSDomainInfo) GetIfExists() bool {
	if m != nil {
		return m.IfExists
	}
	return false
}

// UDNSInfo represents all udns registered in an oracle node
type UDNSInfo struct {
	// basic info
	UdnsCaPubKey   []byte   `protobuf:"bytes,1,opt,name=udns_ca_pub_key,json=udnsCaPubKey,proto3" json:"udns_ca_pub_key,omitempty"`
	TotalDomainNum uint32   `protobuf:"varint,2,opt,name=total_domain_num,json=totalDomainNum,proto3" json:"total_domain_num,omitempty"`
	DomainIdList   []string `protobuf:"bytes,3,rep,name=domain_id_list,json=domainIdList,proto3" json:"domain_id_list,omitempty"`
	// proof of udns domains, verified by udns ca
	UdnsDomains          map[string]*UDNSDomainInfo `protobuf:"bytes,4,rep,name=udns_domains,json=udnsDomains,proto3" json:"udns_domains,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *UDNSInfo) Reset()         { *m = UDNSInfo{} }
func (m *UDNSInfo) String() string { return proto.CompactTextString(m) }
func (*UDNSInfo) ProtoMessage()    {}
func (*UDNSInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{5}
}
func (m *UDNSInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UDNSInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UDNSInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UDNSInfo.Merge(m, src)
}
func (m *UDNSInfo) XXX_Size() int {
	return m.Size()
}
func (m *UDNSInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UDNSInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UDNSInfo proto.InternalMessageInfo

func (m *UDNSInfo) GetUdnsCaPubKey() []byte {
	if m != nil {
		return m.UdnsCaPubKey
	}
	return nil
}

func (m *UDNSInfo) GetTotalDomainNum() uint32 {
	if m != nil {
		return m.TotalDomainNum
	}
	return 0
}

func (m *UDNSInfo) GetDomainIdList() []string {
	if m != nil {
		return m.DomainIdList
	}
	return nil
}

func (m *UDNSInfo) GetUdnsDomains() map[string]*UDNSDomainInfo {
	if m != nil {
		return m.UdnsDomains
	}
	return nil
}

// SGX oracle node represents an oracle node entity
type SGXOracleNode struct {
	// node basic info
	OracleNodeBasicInfo *OracleNodeBasicInfo `protobuf:"bytes,1,opt,name=oracle_node_basic_info,json=oracleNodeBasicInfo,proto3" json:"oracle_node_basic_info,omitempty"`
	// proof of sgx machine identity, verified by oracle's sgx trust root
	SgxProof *SGXProof `protobuf:"bytes,2,opt,name=sgx_proof,json=sgxProof,proto3" json:"sgx_proof,omitempty"`
	// udns info registered in this sgx oracle node
	UdnsInfo             *UDNSInfo `protobuf:"bytes,3,opt,name=udns_info,json=udnsInfo,proto3" json:"udns_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SGXOracleNode) Reset()         { *m = SGXOracleNode{} }
func (m *SGXOracleNode) String() string { return proto.CompactTextString(m) }
func (*SGXOracleNode) ProtoMessage()    {}
func (*SGXOracleNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{6}
}
func (m *SGXOracleNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SGXOracleNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SGXOracleNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SGXOracleNode.Merge(m, src)
}
func (m *SGXOracleNode) XXX_Size() int {
	return m.Size()
}
func (m *SGXOracleNode) XXX_DiscardUnknown() {
	xxx_messageInfo_SGXOracleNode.DiscardUnknown(m)
}

var xxx_messageInfo_SGXOracleNode proto.InternalMessageInfo

func (m *SGXOracleNode) GetOracleNodeBasicInfo() *OracleNodeBasicInfo {
	if m != nil {
		return m.OracleNodeBasicInfo
	}
	return nil
}

func (m *SGXOracleNode) GetSgxProof() *SGXProof {
	if m != nil {
		return m.SgxProof
	}
	return nil
}

func (m *SGXOracleNode) GetUdnsInfo() *UDNSInfo {
	if m != nil {
		return m.UdnsInfo
	}
	return nil
}

type UDNSDomainPKHashInfo struct {
	NodeBizId            string   `protobuf:"bytes,1,opt,name=node_biz_id,json=nodeBizId,proto3" json:"node_biz_id,omitempty"`
	DomainName           string   `protobuf:"bytes,2,opt,name=domain_name,json=domainName,proto3" json:"domain_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UDNSDomainPKHashInfo) Reset()         { *m = UDNSDomainPKHashInfo{} }
func (m *UDNSDomainPKHashInfo) String() string { return proto.CompactTextString(m) }
func (*UDNSDomainPKHashInfo) ProtoMessage()    {}
func (*UDNSDomainPKHashInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{7}
}
func (m *UDNSDomainPKHashInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UDNSDomainPKHashInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *UDNSDomainPKHashInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UDNSDomainPKHashInfo.Merge(m, src)
}
func (m *UDNSDomainPKHashInfo) XXX_Size() int {
	return m.Size()
}
func (m *UDNSDomainPKHashInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UDNSDomainPKHashInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UDNSDomainPKHashInfo proto.InternalMessageInfo

func (m *UDNSDomainPKHashInfo) GetNodeBizId() string {
	if m != nil {
		return m.NodeBizId
	}
	return ""
}

func (m *UDNSDomainPKHashInfo) GetDomainName() string {
	if m != nil {
		return m.DomainName
	}
	return ""
}

// SGXOracleCluster represents an oracle cluster along with some oracle node entities
type SGXOracleCluster struct {
	OracleBasicInfo      *OracleBasicInfo          `protobuf:"bytes,1,opt,name=oracle_basic_info,json=oracleBasicInfo,proto3" json:"oracle_basic_info,omitempty"`
	SgxTrustRoot         *SGXTrustRoot             `protobuf:"bytes,2,opt,name=sgx_trust_root,json=sgxTrustRoot,proto3" json:"sgx_trust_root,omitempty"`
	NodeBizIdList        []string                  `protobuf:"bytes,3,rep,name=node_biz_id_list,json=nodeBizIdList,proto3" json:"node_biz_id_list,omitempty"`
	OracleNodes          map[string]*SGXOracleNode `protobuf:"bytes,4,rep,name=oracle_nodes,json=oracleNodes,proto3" json:"oracle_nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *SGXOracleCluster) Reset()         { *m = SGXOracleCluster{} }
func (m *SGXOracleCluster) String() string { return proto.CompactTextString(m) }
func (*SGXOracleCluster) ProtoMessage()    {}
func (*SGXOracleCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{8}
}
func (m *SGXOracleCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SGXOracleCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SGXOracleCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SGXOracleCluster.Merge(m, src)
}
func (m *SGXOracleCluster) XXX_Size() int {
	return m.Size()
}
func (m *SGXOracleCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_SGXOracleCluster.DiscardUnknown(m)
}

var xxx_messageInfo_SGXOracleCluster proto.InternalMessageInfo

func (m *SGXOracleCluster) GetOracleBasicInfo() *OracleBasicInfo {
	if m != nil {
		return m.OracleBasicInfo
	}
	return nil
}

func (m *SGXOracleCluster) GetSgxTrustRoot() *SGXTrustRoot {
	if m != nil {
		return m.SgxTrustRoot
	}
	return nil
}

func (m *SGXOracleCluster) GetNodeBizIdList() []string {
	if m != nil {
		return m.NodeBizIdList
	}
	return nil
}

func (m *SGXOracleCluster) GetOracleNodes() map[string]*SGXOracleNode {
	if m != nil {
		return m.OracleNodes
	}
	return nil
}

// NOTE: just a wrapper for list of SGXOracleCluster
type SGXOracleClusters struct {
	Clusters             map[string]*SGXOracleCluster `protobuf:"bytes,1,rep,name=clusters,proto3" json:"clusters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *SGXOracleClusters) Reset()         { *m = SGXOracleClusters{} }
func (m *SGXOracleClusters) String() string { return proto.CompactTextString(m) }
func (*SGXOracleClusters) ProtoMessage()    {}
func (*SGXOracleClusters) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{9}
}
func (m *SGXOracleClusters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SGXOracleClusters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *SGXOracleClusters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SGXOracleClusters.Merge(m, src)
}
func (m *SGXOracleClusters) XXX_Size() int {
	return m.Size()
}
func (m *SGXOracleClusters) XXX_DiscardUnknown() {
	xxx_messageInfo_SGXOracleClusters.DiscardUnknown(m)
}

var xxx_messageInfo_SGXOracleClusters proto.InternalMessageInfo

func (m *SGXOracleClusters) GetClusters() map[string]*SGXOracleCluster {
	if m != nil {
		return m.Clusters
	}
	return nil
}

type Counters struct {
	Counters             map[string]uint32 `protobuf:"bytes,1,rep,name=counters,proto3" json:"counters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Counters) Reset()         { *m = Counters{} }
func (m *Counters) String() string { return proto.CompactTextString(m) }
func (*Counters) ProtoMessage()    {}
func (*Counters) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{10}
}
func (m *Counters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Counters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Counters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Counters.Merge(m, src)
}
func (m *Counters) XXX_Size() int {
	return m.Size()
}
func (m *Counters) XXX_DiscardUnknown() {
	xxx_messageInfo_Counters.DiscardUnknown(m)
}

var xxx_messageInfo_Counters proto.InternalMessageInfo

func (m *Counters) GetCounters() map[string]uint32 {
	if m != nil {
		return m.Counters
	}
	return nil
}

type OracleNodePks struct {
	Pks                  map[string]string `protobuf:"bytes,1,rep,name=pks,proto3" json:"pks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *OracleNodePks) Reset()         { *m = OracleNodePks{} }
func (m *OracleNodePks) String() string { return proto.CompactTextString(m) }
func (*OracleNodePks) ProtoMessage()    {}
func (*OracleNodePks) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{11}
}
func (m *OracleNodePks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleNodePks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OracleNodePks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleNodePks.Merge(m, src)
}
func (m *OracleNodePks) XXX_Size() int {
	return m.Size()
}
func (m *OracleNodePks) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleNodePks.DiscardUnknown(m)
}

var xxx_messageInfo_OracleNodePks proto.InternalMessageInfo

func (m *OracleNodePks) GetPks() map[string]string {
	if m != nil {
		return m.Pks
	}
	return nil
}

// ---------------------------------- Service ------------------------------------------
//
type OracleService struct {
	OracleServiceBasicInfo *OracleServiceBasicInfo `protobuf:"bytes,1,opt,name=oracle_service_basic_info,json=oracleServiceBasicInfo,proto3" json:"oracle_service_basic_info,omitempty"`
	PermissionWhitelist    map[string]bool         `protobuf:"bytes,2,rep,name=permission_whitelist,json=permissionWhitelist,proto3" json:"permission_whitelist,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	PermissionBlacklist    map[string]bool         `protobuf:"bytes,3,rep,name=permission_blacklist,json=permissionBlacklist,proto3" json:"permission_blacklist,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral   struct{}                `json:"-"`
	XXX_unrecognized       []byte                  `json:"-"`
	XXX_sizecache          int32                   `json:"-"`
}

func (m *OracleService) Reset()         { *m = OracleService{} }
func (m *OracleService) String() string { return proto.CompactTextString(m) }
func (*OracleService) ProtoMessage()    {}
func (*OracleService) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{12}
}
func (m *OracleService) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleService) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OracleService) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleService.Merge(m, src)
}
func (m *OracleService) XXX_Size() int {
	return m.Size()
}
func (m *OracleService) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleService.DiscardUnknown(m)
}

var xxx_messageInfo_OracleService proto.InternalMessageInfo

func (m *OracleService) GetOracleServiceBasicInfo() *OracleServiceBasicInfo {
	if m != nil {
		return m.OracleServiceBasicInfo
	}
	return nil
}

func (m *OracleService) GetPermissionWhitelist() map[string]bool {
	if m != nil {
		return m.PermissionWhitelist
	}
	return nil
}

func (m *OracleService) GetPermissionBlacklist() map[string]bool {
	if m != nil {
		return m.PermissionBlacklist
	}
	return nil
}

type OracleServiceBasicInfo struct {
	ServiceBizId         string   `protobuf:"bytes,1,opt,name=service_biz_id,json=serviceBizId,proto3" json:"service_biz_id,omitempty"`
	ServiceName          string   `protobuf:"bytes,2,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	ServiceDesc          string   `protobuf:"bytes,3,opt,name=service_desc,json=serviceDesc,proto3" json:"service_desc,omitempty"`
	OracleBizId          string   `protobuf:"bytes,4,opt,name=oracle_biz_id,json=oracleBizId,proto3" json:"oracle_biz_id,omitempty"`
	ServiceStatus        string   `protobuf:"bytes,5,opt,name=service_status,json=serviceStatus,proto3" json:"service_status,omitempty"`
	DataSource           string   `protobuf:"bytes,6,opt,name=data_source,json=dataSource,proto3" json:"data_source,omitempty"`
	PermissionPolicy     string   `protobuf:"bytes,7,opt,name=permission_policy,json=permissionPolicy,proto3" json:"permission_policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OracleServiceBasicInfo) Reset()         { *m = OracleServiceBasicInfo{} }
func (m *OracleServiceBasicInfo) String() string { return proto.CompactTextString(m) }
func (*OracleServiceBasicInfo) ProtoMessage()    {}
func (*OracleServiceBasicInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{13}
}
func (m *OracleServiceBasicInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleServiceBasicInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OracleServiceBasicInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleServiceBasicInfo.Merge(m, src)
}
func (m *OracleServiceBasicInfo) XXX_Size() int {
	return m.Size()
}
func (m *OracleServiceBasicInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleServiceBasicInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OracleServiceBasicInfo proto.InternalMessageInfo

func (m *OracleServiceBasicInfo) GetServiceBizId() string {
	if m != nil {
		return m.ServiceBizId
	}
	return ""
}

func (m *OracleServiceBasicInfo) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *OracleServiceBasicInfo) GetServiceDesc() string {
	if m != nil {
		return m.ServiceDesc
	}
	return ""
}

func (m *OracleServiceBasicInfo) GetOracleBizId() string {
	if m != nil {
		return m.OracleBizId
	}
	return ""
}

func (m *OracleServiceBasicInfo) GetServiceStatus() string {
	if m != nil {
		return m.ServiceStatus
	}
	return ""
}

func (m *OracleServiceBasicInfo) GetDataSource() string {
	if m != nil {
		return m.DataSource
	}
	return ""
}

func (m *OracleServiceBasicInfo) GetPermissionPolicy() string {
	if m != nil {
		return m.PermissionPolicy
	}
	return ""
}

// NOTE: just a wrapper for list of OracleService
type OracleServices struct {
	Services             map[string]*OracleService `protobuf:"bytes,1,rep,name=services,proto3" json:"services,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *OracleServices) Reset()         { *m = OracleServices{} }
func (m *OracleServices) String() string { return proto.CompactTextString(m) }
func (*OracleServices) ProtoMessage()    {}
func (*OracleServices) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{14}
}
func (m *OracleServices) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleServices) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OracleServices) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleServices.Merge(m, src)
}
func (m *OracleServices) XXX_Size() int {
	return m.Size()
}
func (m *OracleServices) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleServices.DiscardUnknown(m)
}

var xxx_messageInfo_OracleServices proto.InternalMessageInfo

func (m *OracleServices) GetServices() map[string]*OracleService {
	if m != nil {
		return m.Services
	}
	return nil
}

type Request struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	BizId                string   `protobuf:"bytes,2,opt,name=biz_id,json=bizId,proto3" json:"biz_id,omitempty"`
	Body                 string   `protobuf:"bytes,3,opt,name=body,proto3" json:"body,omitempty"`
	ServiceBizId         string   `protobuf:"bytes,4,opt,name=service_biz_id,json=serviceBizId,proto3" json:"service_biz_id,omitempty"`
	DataSource           string   `protobuf:"bytes,5,opt,name=data_source,json=dataSource,proto3" json:"data_source,omitempty"`
	IfCallback           bool     `protobuf:"varint,6,opt,name=if_callback,json=ifCallback,proto3" json:"if_callback,omitempty"`
	CallIdentity         string   `protobuf:"bytes,7,opt,name=call_identity,json=callIdentity,proto3" json:"call_identity,omitempty"`
	CallbackIdentity     string   `protobuf:"bytes,8,opt,name=callback_identity,json=callbackIdentity,proto3" json:"callback_identity,omitempty"`
	DelayTime            uint64   `protobuf:"varint,9,opt,name=delay_time,json=delayTime,proto3" json:"delay_time,omitempty"`
	IfSuccess            bool     `protobuf:"varint,10,opt,name=if_success,json=ifSuccess,proto3" json:"if_success,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{15}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Request) GetBizId() string {
	if m != nil {
		return m.BizId
	}
	return ""
}

func (m *Request) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *Request) GetServiceBizId() string {
	if m != nil {
		return m.ServiceBizId
	}
	return ""
}

func (m *Request) GetDataSource() string {
	if m != nil {
		return m.DataSource
	}
	return ""
}

func (m *Request) GetIfCallback() bool {
	if m != nil {
		return m.IfCallback
	}
	return false
}

func (m *Request) GetCallIdentity() string {
	if m != nil {
		return m.CallIdentity
	}
	return ""
}

func (m *Request) GetCallbackIdentity() string {
	if m != nil {
		return m.CallbackIdentity
	}
	return ""
}

func (m *Request) GetDelayTime() uint64 {
	if m != nil {
		return m.DelayTime
	}
	return 0
}

func (m *Request) GetIfSuccess() bool {
	if m != nil {
		return m.IfSuccess
	}
	return false
}

type Requests struct {
	Reqs                 map[string]*Request `protobuf:"bytes,1,rep,name=reqs,proto3" json:"reqs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Requests) Reset()         { *m = Requests{} }
func (m *Requests) String() string { return proto.CompactTextString(m) }
func (*Requests) ProtoMessage()    {}
func (*Requests) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{16}
}
func (m *Requests) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Requests) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Requests) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Requests.Merge(m, src)
}
func (m *Requests) XXX_Size() int {
	return m.Size()
}
func (m *Requests) XXX_DiscardUnknown() {
	xxx_messageInfo_Requests.DiscardUnknown(m)
}

var xxx_messageInfo_Requests proto.InternalMessageInfo

func (m *Requests) GetReqs() map[string]*Request {
	if m != nil {
		return m.Reqs
	}
	return nil
}

type Response struct {
	ReqId     string `protobuf:"bytes,1,opt,name=req_id,json=reqId,proto3" json:"req_id,omitempty"`
	ServiceId string `protobuf:"bytes,2,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	ReqBody   []byte `protobuf:"bytes,3,opt,name=req_body,json=reqBody,proto3" json:"req_body,omitempty"`
	ResHeader []byte `protobuf:"bytes,4,opt,name=res_header,json=resHeader,proto3" json:"res_header,omitempty"`
	ResBody   []byte `protobuf:"bytes,5,opt,name=res_body,json=resBody,proto3" json:"res_body,omitempty"`
	// tlv data {request|error_code|error_msg|response_body}
	SigningBody          []byte   `protobuf:"bytes,6,opt,name=signing_body,json=signingBody,proto3" json:"signing_body,omitempty"`
	SigType              uint32   `protobuf:"varint,7,opt,name=sig_type,json=sigType,proto3" json:"sig_type,omitempty"`
	Sig                  []byte   `protobuf:"bytes,8,opt,name=sig,proto3" json:"sig,omitempty"`
	PubKeyHash           string   `protobuf:"bytes,9,opt,name=pub_key_hash,json=pubKeyHash,proto3" json:"pub_key_hash,omitempty"`
	ErrorCode            uint32   `protobuf:"varint,10,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	ErrorMsg             string   `protobuf:"bytes,11,opt,name=error_msg,json=errorMsg,proto3" json:"error_msg,omitempty"`
	HttpStatus           uint32   `protobuf:"varint,12,opt,name=http_status,json=httpStatus,proto3" json:"http_status,omitempty"`
	Domain               string   `protobuf:"bytes,13,opt,name=domain,proto3" json:"domain,omitempty"`
	Version              uint32   `protobuf:"varint,14,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{17}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *Response) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *Response) GetReqBody() []byte {
	if m != nil {
		return m.ReqBody
	}
	return nil
}

func (m *Response) GetResHeader() []byte {
	if m != nil {
		return m.ResHeader
	}
	return nil
}

func (m *Response) GetResBody() []byte {
	if m != nil {
		return m.ResBody
	}
	return nil
}

func (m *Response) GetSigningBody() []byte {
	if m != nil {
		return m.SigningBody
	}
	return nil
}

func (m *Response) GetSigType() uint32 {
	if m != nil {
		return m.SigType
	}
	return 0
}

func (m *Response) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *Response) GetPubKeyHash() string {
	if m != nil {
		return m.PubKeyHash
	}
	return ""
}

func (m *Response) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *Response) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

func (m *Response) GetHttpStatus() uint32 {
	if m != nil {
		return m.HttpStatus
	}
	return 0
}

func (m *Response) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Response) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type Responses struct {
	Resps                map[string]*Response `protobuf:"bytes,1,rep,name=resps,proto3" json:"resps,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Responses) Reset()         { *m = Responses{} }
func (m *Responses) String() string { return proto.CompactTextString(m) }
func (*Responses) ProtoMessage()    {}
func (*Responses) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{18}
}
func (m *Responses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Responses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *Responses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Responses.Merge(m, src)
}
func (m *Responses) XXX_Size() int {
	return m.Size()
}
func (m *Responses) XXX_DiscardUnknown() {
	xxx_messageInfo_Responses.DiscardUnknown(m)
}

var xxx_messageInfo_Responses proto.InternalMessageInfo

func (m *Responses) GetResps() map[string]*Response {
	if m != nil {
		return m.Resps
	}
	return nil
}

// ---------------------------------- AuthMsg ------------------------------------------
type TransProtocol struct {
	// recv msg routing: type -> protocoal chaincode mapping
	Protocols map[uint64]string `protobuf:"bytes,1,rep,name=protocols,proto3" json:"protocols,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// out msg type: protocoal chaincode -> type
	Allowtypes           map[string]uint64 `protobuf:"bytes,2,rep,name=allowtypes,proto3" json:"allowtypes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TransProtocol) Reset()         { *m = TransProtocol{} }
func (m *TransProtocol) String() string { return proto.CompactTextString(m) }
func (*TransProtocol) ProtoMessage()    {}
func (*TransProtocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{19}
}
func (m *TransProtocol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransProtocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *TransProtocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransProtocol.Merge(m, src)
}
func (m *TransProtocol) XXX_Size() int {
	return m.Size()
}
func (m *TransProtocol) XXX_DiscardUnknown() {
	xxx_messageInfo_TransProtocol.DiscardUnknown(m)
}

var xxx_messageInfo_TransProtocol proto.InternalMessageInfo

func (m *TransProtocol) GetProtocols() map[uint64]string {
	if m != nil {
		return m.Protocols
	}
	return nil
}

func (m *TransProtocol) GetAllowtypes() map[string]uint64 {
	if m != nil {
		return m.Allowtypes
	}
	return nil
}

type OracleContract struct {
	Chaincode            string   `protobuf:"bytes,1,opt,name=chaincode,proto3" json:"chaincode,omitempty"`
	Serviceid            []byte   `protobuf:"bytes,2,opt,name=serviceid,proto3" json:"serviceid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OracleContract) Reset()         { *m = OracleContract{} }
func (m *OracleContract) String() string { return proto.CompactTextString(m) }
func (*OracleContract) ProtoMessage()    {}
func (*OracleContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{20}
}
func (m *OracleContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OracleContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *OracleContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OracleContract.Merge(m, src)
}
func (m *OracleContract) XXX_Size() int {
	return m.Size()
}
func (m *OracleContract) XXX_DiscardUnknown() {
	xxx_messageInfo_OracleContract.DiscardUnknown(m)
}

var xxx_messageInfo_OracleContract proto.InternalMessageInfo

func (m *OracleContract) GetChaincode() string {
	if m != nil {
		return m.Chaincode
	}
	return ""
}

func (m *OracleContract) GetServiceid() []byte {
	if m != nil {
		return m.Serviceid
	}
	return nil
}

type DomainParser struct {
	// key -> domain, value -> parser chaincode
	Parsers              map[string]string `protobuf:"bytes,1,rep,name=parsers,proto3" json:"parsers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DomainParser) Reset()         { *m = DomainParser{} }
func (m *DomainParser) String() string { return proto.CompactTextString(m) }
func (*DomainParser) ProtoMessage()    {}
func (*DomainParser) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{21}
}
func (m *DomainParser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainParser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DomainParser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainParser.Merge(m, src)
}
func (m *DomainParser) XXX_Size() int {
	return m.Size()
}
func (m *DomainParser) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainParser.DiscardUnknown(m)
}

var xxx_messageInfo_DomainParser proto.InternalMessageInfo

func (m *DomainParser) GetParsers() map[string]string {
	if m != nil {
		return m.Parsers
	}
	return nil
}

type MsgNounce struct {
	Seqno                uint32   `protobuf:"varint,1,opt,name=seqno,proto3" json:"seqno,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgNounce) Reset()         { *m = MsgNounce{} }
func (m *MsgNounce) String() string { return proto.CompactTextString(m) }
func (*MsgNounce) ProtoMessage()    {}
func (*MsgNounce) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{22}
}
func (m *MsgNounce) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNounce) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *MsgNounce) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNounce.Merge(m, src)
}
func (m *MsgNounce) XXX_Size() int {
	return m.Size()
}
func (m *MsgNounce) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNounce.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNounce proto.InternalMessageInfo

func (m *MsgNounce) GetSeqno() uint32 {
	if m != nil {
		return m.Seqno
	}
	return 0
}

type DomainPks struct {
	DomainPks            map[string]*UDNSDomainPKHashInfo `protobuf:"bytes,1,rep,name=domain_pks,json=domainPks,proto3" json:"domain_pks,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DomainPks) Reset()         { *m = DomainPks{} }
func (m *DomainPks) String() string { return proto.CompactTextString(m) }
func (*DomainPks) ProtoMessage()    {}
func (*DomainPks) Descriptor() ([]byte, []int) {
	return fileDescriptor_97136ef4b384cc22, []int{23}
}
func (m *DomainPks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainPks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalToSizedBuffer(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (m *DomainPks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainPks.Merge(m, src)
}
func (m *DomainPks) XXX_Size() int {
	return m.Size()
}
func (m *DomainPks) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainPks.DiscardUnknown(m)
}

var xxx_messageInfo_DomainPks proto.InternalMessageInfo

func (m *DomainPks) GetDomainPks() map[string]*UDNSDomainPKHashInfo {
	if m != nil {
		return m.DomainPks
	}
	return nil
}

func init() {
	proto.RegisterType((*OracleBasicInfo)(nil), "chaincodepb.OracleBasicInfo")
	proto.RegisterType((*SGXTrustRoot)(nil), "chaincodepb.SGXTrustRoot")
	proto.RegisterType((*OracleNodeBasicInfo)(nil), "chaincodepb.OracleNodeBasicInfo")
	proto.RegisterType((*SGXProof)(nil), "chaincodepb.SGXProof")
	proto.RegisterType((*UDNSDomainInfo)(nil), "chaincodepb.UDNSDomainInfo")
	proto.RegisterType((*UDNSInfo)(nil), "chaincodepb.UDNSInfo")
	proto.RegisterMapType((map[string]*UDNSDomainInfo)(nil), "chaincodepb.UDNSInfo.UdnsDomainsEntry")
	proto.RegisterType((*SGXOracleNode)(nil), "chaincodepb.SGXOracleNode")
	proto.RegisterType((*UDNSDomainPKHashInfo)(nil), "chaincodepb.UDNSDomainPKHashInfo")
	proto.RegisterType((*SGXOracleCluster)(nil), "chaincodepb.SGXOracleCluster")
	proto.RegisterMapType((map[string]*SGXOracleNode)(nil), "chaincodepb.SGXOracleCluster.OracleNodesEntry")
	proto.RegisterType((*SGXOracleClusters)(nil), "chaincodepb.SGXOracleClusters")
	proto.RegisterMapType((map[string]*SGXOracleCluster)(nil), "chaincodepb.SGXOracleClusters.ClustersEntry")
	proto.RegisterType((*Counters)(nil), "chaincodepb.Counters")
	proto.RegisterMapType((map[string]uint32)(nil), "chaincodepb.Counters.CountersEntry")
	proto.RegisterType((*OracleNodePks)(nil), "chaincodepb.OracleNodePks")
	proto.RegisterMapType((map[string]string)(nil), "chaincodepb.OracleNodePks.PksEntry")
	proto.RegisterType((*OracleService)(nil), "chaincodepb.OracleService")
	proto.RegisterMapType((map[string]bool)(nil), "chaincodepb.OracleService.PermissionBlacklistEntry")
	proto.RegisterMapType((map[string]bool)(nil), "chaincodepb.OracleService.PermissionWhitelistEntry")
	proto.RegisterType((*OracleServiceBasicInfo)(nil), "chaincodepb.OracleServiceBasicInfo")
	proto.RegisterType((*OracleServices)(nil), "chaincodepb.OracleServices")
	proto.RegisterMapType((map[string]*OracleService)(nil), "chaincodepb.OracleServices.ServicesEntry")
	proto.RegisterType((*Request)(nil), "chaincodepb.Request")
	proto.RegisterType((*Requests)(nil), "chaincodepb.Requests")
	proto.RegisterMapType((map[string]*Request)(nil), "chaincodepb.Requests.ReqsEntry")
	proto.RegisterType((*Response)(nil), "chaincodepb.Response")
	proto.RegisterType((*Responses)(nil), "chaincodepb.Responses")
	proto.RegisterMapType((map[string]*Response)(nil), "chaincodepb.Responses.RespsEntry")
	proto.RegisterType((*TransProtocol)(nil), "chaincodepb.TransProtocol")
	proto.RegisterMapType((map[string]uint64)(nil), "chaincodepb.TransProtocol.AllowtypesEntry")
	proto.RegisterMapType((map[uint64]string)(nil), "chaincodepb.TransProtocol.ProtocolsEntry")
	proto.RegisterType((*OracleContract)(nil), "chaincodepb.OracleContract")
	proto.RegisterType((*DomainParser)(nil), "chaincodepb.DomainParser")
	proto.RegisterMapType((map[string]string)(nil), "chaincodepb.DomainParser.ParsersEntry")
	proto.RegisterType((*MsgNounce)(nil), "chaincodepb.MsgNounce")
	proto.RegisterType((*DomainPks)(nil), "chaincodepb.DomainPks")
	proto.RegisterMapType((map[string]*UDNSDomainPKHashInfo)(nil), "chaincodepb.DomainPks.DomainPksEntry")
}

func init() { proto.RegisterFile("chaincode.proto", fileDescriptor_97136ef4b384cc22) }

var fileDescriptor_97136ef4b384cc22 = []byte{
	// 2053 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xcd, 0x93, 0xdc, 0x46,
	0x15, 0x47, 0x33, 0xfb, 0x21, 0xbd, 0xd1, 0xec, 0x8e, 0xe5, 0x0f, 0xc6, 0xe3, 0x78, 0xbd, 0x9e,
	0xe0, 0x64, 0x13, 0xc3, 0x04, 0xd6, 0x05, 0xa1, 0x02, 0x54, 0xf0, 0x7e, 0xc4, 0x5e, 0x12, 0x6f,
	0x16, 0x8d, 0xbf, 0x2a, 0x54, 0xa1, 0xea, 0x91, 0x7a, 0x66, 0xbb, 0x76, 0x46, 0xd2, 0xaa, 0xa5,
	0xb5, 0x37, 0x07, 0xce, 0x14, 0x05, 0xdc, 0xa0, 0xb8, 0x70, 0xe0, 0xc8, 0x8d, 0xe2, 0x46, 0x15,
	0x47, 0x0e, 0x9c, 0x80, 0x23, 0xc7, 0x94, 0xf9, 0x1b, 0xb8, 0x53, 0xfd, 0xba, 0x5b, 0x1f, 0xb3,
	0xb2, 0x17, 0x57, 0xe5, 0xa4, 0xd6, 0xaf, 0x5f, 0xf7, 0xfb, 0xf8, 0xbd, 0x7e, 0xdd, 0x0f, 0x56,
	0xfd, 0x43, 0xc2, 0x42, 0x3f, 0x0a, 0xe8, 0x20, 0x4e, 0xa2, 0x34, 0x72, 0x5a, 0x39, 0x10, 0x8f,
	0x7a, 0xdf, 0x98, 0xb0, 0xf4, 0x30, 0x1b, 0x0d, 0xfc, 0x68, 0xf6, 0xde, 0x24, 0x9a, 0x44, 0xef,
	0xa1, 0xcc, 0x28, 0x1b, 0xe3, 0x1f, 0xfe, 0xe0, 0x48, 0xae, 0xed, 0x7f, 0x61, 0xc0, 0xea, 0xa7,
	0x09, 0xf1, 0xa7, 0x74, 0x8b, 0x70, 0xe6, 0xef, 0x85, 0xe3, 0xc8, 0xf9, 0x1a, 0xac, 0x44, 0x08,
	0x79, 0x87, 0x84, 0x1f, 0x7a, 0x2c, 0xe8, 0x1a, 0xeb, 0xc6, 0x86, 0xed, 0xda, 0x12, 0xbd, 0x4f,
	0xf8, 0xe1, 0x5e, 0xe0, 0xf4, 0xa1, 0xad, 0xa4, 0x46, 0xec, 0x73, 0x21, 0xd4, 0x58, 0x37, 0x36,
	0x2c, 0xb7, 0x25, 0xc1, 0x2d, 0xf6, 0xf9, 0x5e, 0xe0, 0xdc, 0x00, 0xf5, 0xeb, 0x85, 0x64, 0x46,
	0xbb, 0x4d, 0x94, 0x00, 0x09, 0xed, 0x93, 0x19, 0x2d, 0x09, 0x04, 0x94, 0xfb, 0xdd, 0x85, 0xb2,
	0xc0, 0x0e, 0xe5, 0xbe, 0xb0, 0x25, 0x8d, 0x52, 0x32, 0xf5, 0xc2, 0x28, 0xa0, 0x5e, 0x98, 0xcd,
	0xba, 0x8b, 0xeb, 0xc6, 0x46, 0xdb, 0xb5, 0x11, 0xdd, 0x8f, 0x02, 0xba, 0x9f, 0xcd, 0x9c, 0x6b,
	0x60, 0xb1, 0xb1, 0x47, 0x9f, 0x33, 0x9e, 0xf2, 0xee, 0xd2, 0xba, 0xb1, 0x61, 0xba, 0x26, 0x1b,
	0xef, 0xe2, 0x7f, 0xff, 0x6f, 0x06, 0xd8, 0xc3, 0x7b, 0x4f, 0x1f, 0x26, 0x19, 0x4f, 0xdd, 0x28,
	0x4a, 0x9d, 0xab, 0x60, 0x32, 0xc2, 0xa5, 0x46, 0x03, 0x35, 0x2e, 0x33, 0xc2, 0x51, 0xdd, 0x1a,
	0xb4, 0xc4, 0x54, 0x9c, 0x8d, 0xbc, 0x23, 0x7a, 0xaa, 0x5c, 0xb2, 0x18, 0xe1, 0x07, 0xd9, 0xe8,
	0x63, 0x7a, 0xea, 0x7c, 0x15, 0x96, 0x93, 0x28, 0x4a, 0x3d, 0x9f, 0x28, 0x67, 0x96, 0xc4, 0xef,
	0x36, 0x71, 0xae, 0x03, 0xcc, 0x12, 0x8f, 0x86, 0xfe, 0x94, 0x9c, 0x50, 0xf4, 0xc3, 0x76, 0xad,
	0x59, 0xb2, 0x2b, 0x01, 0xe1, 0x06, 0x1b, 0x7b, 0x31, 0x7f, 0xe6, 0xf1, 0x2c, 0x8e, 0xa3, 0x24,
	0x45, 0x37, 0x4c, 0xd7, 0x66, 0xe3, 0x03, 0xfe, 0x6c, 0x28, 0xb1, 0x57, 0xbb, 0xf1, 0xab, 0x26,
	0x5c, 0x94, 0x4c, 0x09, 0xaf, 0x0b, 0xb6, 0xd6, 0xc1, 0xc6, 0xd8, 0x54, 0xb9, 0x02, 0x81, 0x29,
	0xa6, 0xd6, 0xa0, 0x85, 0x12, 0x15, 0x9e, 0x2c, 0x01, 0x49, 0x96, 0xae, 0x81, 0x25, 0xa3, 0x5b,
	0x70, 0x64, 0x0a, 0x00, 0x19, 0xd2, 0x93, 0x25, 0x7e, 0x70, 0x52, 0x87, 0x2b, 0xe1, 0x24, 0x0f,
	0xd7, 0xa2, 0x74, 0x3b, 0xe1, 0x44, 0x85, 0xab, 0x0f, 0x6d, 0xea, 0x07, 0x25, 0x89, 0x25, 0x94,
	0x68, 0x21, 0xa8, 0x64, 0x6e, 0x82, 0xed, 0x47, 0x59, 0x98, 0xd2, 0xc4, 0x1b, 0x4f, 0xc9, 0xa4,
	0xbb, 0x8c, 0xfc, 0xb6, 0x14, 0xf6, 0xd1, 0x94, 0x4c, 0x9c, 0xb7, 0x60, 0x55, 0x8b, 0xb0, 0x00,
	0x1d, 0xed, 0x9a, 0xb8, 0x51, 0x5b, 0xc1, 0x7b, 0x81, 0x70, 0xd5, 0x79, 0x13, 0x34, 0xe0, 0x9d,
	0x90, 0x69, 0x46, 0xbb, 0x96, 0xcc, 0x15, 0x05, 0x3e, 0x16, 0x98, 0xf3, 0x0e, 0x74, 0x4e, 0x68,
	0xc2, 0xc6, 0xa7, 0x5e, 0xca, 0x66, 0x94, 0xa7, 0x64, 0x16, 0x77, 0x01, 0xe5, 0x56, 0x25, 0xfe,
	0x50, 0xc3, 0x55, 0x3e, 0x5a, 0x73, 0x7c, 0xa4, 0x60, 0x0e, 0xef, 0x3d, 0x3d, 0x48, 0xa2, 0x68,
	0xec, 0x74, 0xa0, 0x79, 0xf7, 0xb1, 0xab, 0x92, 0x49, 0x0c, 0x45, 0xa2, 0xdc, 0x7d, 0xec, 0x7a,
	0x9c, 0x4d, 0x54, 0xbc, 0x97, 0xee, 0x3e, 0x76, 0x87, 0x6c, 0x82, 0x99, 0x40, 0xb8, 0xe7, 0xd3,
	0x24, 0xf5, 0xf0, 0xdc, 0xaa, 0x88, 0xdb, 0x8c, 0xf0, 0x6d, 0x9a, 0xa4, 0xdb, 0x02, 0xc3, 0x3c,
	0x23, 0x5e, 0x40, 0x52, 0xa2, 0x62, 0xbe, 0x94, 0x90, 0x1d, 0x92, 0x92, 0xfe, 0x2f, 0x9a, 0xb0,
	0xf2, 0x68, 0x67, 0x7f, 0xb8, 0x13, 0xcd, 0x08, 0x0b, 0xf5, 0x71, 0x0d, 0xf0, 0x6f, 0xfe, 0xb8,
	0x4a, 0x54, 0x25, 0xc1, 0x0d, 0x68, 0x29, 0x29, 0xa4, 0x59, 0x1a, 0x05, 0x12, 0xd2, 0x44, 0x67,
	0x41, 0x28, 0x2d, 0x43, 0x9b, 0x6c, 0xd7, 0x14, 0x80, 0x30, 0xaa, 0xb4, 0x1a, 0xa7, 0x65, 0x7e,
	0xab, 0xd5, 0x28, 0xf0, 0x36, 0x74, 0x70, 0xf5, 0xd9, 0x74, 0x68, 0x0b, 0xdc, 0xcd, 0xe9, 0xbe,
	0x0d, 0x0e, 0x0a, 0xd6, 0xe5, 0xc5, 0xaa, 0x98, 0xd9, 0xad, 0xe6, 0x06, 0x67, 0x93, 0x90, 0x85,
	0x13, 0x6f, 0x14, 0x05, 0xa7, 0x98, 0x1b, 0xb6, 0xdb, 0x52, 0xd8, 0x56, 0x14, 0x9c, 0x8a, 0xf4,
	0x57, 0x9b, 0x94, 0x13, 0x03, 0x62, 0xdc, 0x00, 0xb3, 0xa2, 0x03, 0x4d, 0x41, 0x83, 0x85, 0x13,
	0x62, 0xf8, 0xa5, 0xa5, 0xc0, 0x1f, 0x1b, 0x60, 0x0a, 0x32, 0x90, 0x86, 0x5b, 0xb0, 0x2a, 0xe3,
	0x57, 0x78, 0xa5, 0x78, 0xc0, 0x28, 0x6a, 0x97, 0x36, 0xa0, 0x23, 0x0b, 0x9a, 0x66, 0x23, 0x9b,
	0x21, 0x19, 0x6d, 0x57, 0x16, 0x3a, 0x49, 0xac, 0x28, 0x6a, 0x05, 0xaf, 0x2c, 0xf0, 0xa6, 0x8c,
	0x0b, 0x56, 0x9a, 0x22, 0x53, 0x24, 0xba, 0x17, 0x7c, 0xc2, 0x78, 0xea, 0xec, 0x01, 0xee, 0xaf,
	0xb6, 0xe3, 0xdd, 0x85, 0xf5, 0xe6, 0x46, 0x6b, 0xf3, 0xad, 0x41, 0xe9, 0x4e, 0x18, 0x68, 0x1b,
	0x07, 0x8f, 0x82, 0x90, 0x4b, 0x05, 0x7c, 0x37, 0x4c, 0x93, 0x53, 0xb7, 0x95, 0x15, 0x48, 0xef,
	0x27, 0xd0, 0x99, 0x17, 0x10, 0xc1, 0xd3, 0x9e, 0x58, 0xae, 0x18, 0x3a, 0xdf, 0x82, 0x45, 0x79,
	0xb8, 0x84, 0xd5, 0xad, 0xcd, 0x6b, 0x67, 0x34, 0x15, 0xa9, 0xe9, 0x4a, 0xc9, 0x0f, 0x1a, 0xdf,
	0x35, 0xfa, 0xff, 0x30, 0xa0, 0x3d, 0xbc, 0xf7, 0xb4, 0xa8, 0x60, 0xce, 0x23, 0xb8, 0xa2, 0x2f,
	0x07, 0xac, 0x4e, 0xa2, 0xa2, 0x79, 0x2c, 0x1c, 0x47, 0xa8, 0xad, 0xb5, 0xb9, 0x5e, 0xd9, 0xb9,
	0xa6, 0xf4, 0xb9, 0x17, 0xa3, 0x9a, 0x7a, 0xb8, 0x09, 0x16, 0x9f, 0x3c, 0xf7, 0x62, 0x71, 0x30,
	0x95, 0x8d, 0x97, 0x2b, 0x3b, 0xe9, 0x53, 0xeb, 0x9a, 0x7c, 0xf2, 0x5c, 0x9e, 0xdf, 0x4d, 0x95,
	0xfb, 0xa8, 0xbd, 0x59, 0xb3, 0x46, 0x47, 0x50, 0x1e, 0x09, 0x31, 0xea, 0x3f, 0x81, 0x4b, 0x85,
	0xb7, 0x07, 0x1f, 0xe3, 0x31, 0x13, 0xfa, 0xe7, 0xaa, 0xad, 0x31, 0x5f, 0x6d, 0xcf, 0x3b, 0x88,
	0xfd, 0xff, 0x36, 0xa0, 0x93, 0x47, 0x6a, 0x7b, 0x9a, 0xf1, 0x94, 0x26, 0xce, 0x7d, 0xb8, 0xa0,
	0x6f, 0xdb, 0xf9, 0x38, 0xbd, 0x51, 0x13, 0xa7, 0x22, 0x46, 0xab, 0xd1, 0xdc, 0xed, 0xfe, 0x21,
	0xac, 0x88, 0xf8, 0xa4, 0xe2, 0x3a, 0xf4, 0xc4, 0xed, 0xa5, 0x82, 0x74, 0x75, 0x3e, 0x48, 0xf9,
	0x85, 0xe9, 0xda, 0x7c, 0xf2, 0xbc, 0xb8, 0x3e, 0xdf, 0x86, 0x4e, 0xc9, 0xc1, 0x72, 0x66, 0xb6,
	0x73, 0x2f, 0x31, 0x35, 0x7f, 0x0c, 0x76, 0x89, 0x60, 0x9d, 0x9a, 0x83, 0x79, 0x3d, 0x15, 0x47,
	0x4b, 0x3c, 0xeb, 0x14, 0x2d, 0x48, 0xe6, 0xbd, 0xcf, 0xa0, 0x33, 0x2f, 0x50, 0x93, 0xa2, 0xdf,
	0xac, 0xa6, 0x68, 0xaf, 0x5e, 0xa3, 0xd8, 0xa2, 0x9c, 0xa1, 0x7f, 0x31, 0xe0, 0xc2, 0xbc, 0x39,
	0xdc, 0xb9, 0x0f, 0xa6, 0xaf, 0xc6, 0x5d, 0x03, 0x1d, 0xf8, 0xfa, 0x2b, 0x1d, 0xe0, 0x03, 0x3d,
	0x90, 0xe6, 0xe7, 0xab, 0x7b, 0x9f, 0x41, 0xbb, 0x32, 0x55, 0x63, 0xf8, 0x9d, 0xaa, 0xe1, 0xd7,
	0x5f, 0xa9, 0xa9, 0x6c, 0xfb, 0xcf, 0x0d, 0x30, 0xb7, 0xe5, 0x2d, 0xc7, 0x9d, 0x0f, 0xc1, 0x54,
	0x37, 0x9e, 0x36, 0xf9, 0xcd, 0xca, 0x46, 0x5a, 0x30, 0x1f, 0x68, 0x4b, 0xd5, 0x6f, 0xef, 0x7b,
	0xd0, 0xae, 0x4c, 0xd5, 0x58, 0x7a, 0xa9, 0x6c, 0x69, 0xbb, 0x6c, 0xca, 0xcf, 0xa0, 0x5d, 0xc4,
	0xf7, 0xe0, 0x88, 0x3b, 0xdf, 0x86, 0x66, 0x7c, 0x54, 0x6f, 0x49, 0x45, 0x70, 0x70, 0x70, 0xa4,
	0x2c, 0x11, 0xf2, 0xbd, 0xef, 0x80, 0xa9, 0x81, 0xf3, 0xf4, 0x5b, 0x65, 0xfd, 0xff, 0x6c, 0x6a,
	0x03, 0x86, 0x34, 0x39, 0x61, 0x3e, 0x75, 0x7e, 0x0a, 0x57, 0x55, 0x1e, 0x72, 0x89, 0x9c, 0x3d,
	0x43, 0x75, 0x66, 0xa9, 0xe5, 0xc5, 0x51, 0x52, 0xe5, 0x6a, 0x1e, 0x77, 0xc6, 0x70, 0x29, 0xa6,
	0xc9, 0x8c, 0x71, 0xce, 0xa2, 0xd0, 0x7b, 0x76, 0xc8, 0x52, 0x8a, 0x87, 0xa2, 0x81, 0x1e, 0xdf,
	0x79, 0xf9, 0xd6, 0x83, 0x83, 0x7c, 0xd9, 0x13, 0xbd, 0x4a, 0x46, 0xe0, 0x62, 0x7c, 0x76, 0x66,
	0x4e, 0xcf, 0x68, 0x4a, 0xfc, 0xa3, 0xfc, 0xf0, 0xfd, 0xbf, 0x7a, 0xb6, 0xf4, 0xaa, 0x33, 0x7a,
	0xf2, 0x99, 0xde, 0x47, 0xd0, 0x7d, 0x99, 0x61, 0xe7, 0x31, 0x61, 0x96, 0x98, 0xa8, 0xee, 0x53,
	0x55, 0xfc, 0x3a, 0xfb, 0xf4, 0x7f, 0xdf, 0x80, 0x2b, 0xf5, 0x94, 0x88, 0x3b, 0x32, 0xe7, 0xb4,
	0x5c, 0x6f, 0x6d, 0x85, 0xca, 0x92, 0x2b, 0x9e, 0x11, 0x4a, 0xaa, 0x54, 0x73, 0x5b, 0x0a, 0xc3,
	0xd7, 0x4f, 0x49, 0x04, 0x5f, 0xba, 0xcd, 0x8a, 0x08, 0x3e, 0x76, 0xcf, 0x34, 0x3c, 0x0b, 0x67,
	0x1b, 0x9e, 0x5b, 0x85, 0x3d, 0x3c, 0x25, 0x69, 0xc6, 0xf1, 0x11, 0x64, 0xb9, 0x6d, 0x85, 0x0e,
	0x11, 0xc4, 0x3b, 0x80, 0xa4, 0xc4, 0xe3, 0x51, 0x96, 0xf8, 0x14, 0x5f, 0x3f, 0xe2, 0x0e, 0x20,
	0x29, 0x19, 0x22, 0xe2, 0xdc, 0x86, 0x0b, 0x25, 0xaa, 0xe3, 0x68, 0xca, 0x7c, 0xf9, 0xfa, 0xb1,
	0xdc, 0x4e, 0x31, 0x71, 0x80, 0x78, 0xff, 0x4f, 0x06, 0xac, 0x54, 0xe2, 0xc3, 0x9d, 0x5d, 0x30,
	0x95, 0x46, 0x7d, 0xf0, 0xde, 0x79, 0x79, 0x7a, 0xf0, 0x81, 0x1e, 0xa8, 0x42, 0xa0, 0x97, 0xf6,
	0x9e, 0x40, 0xbb, 0x32, 0xf5, 0xba, 0xb5, 0xb6, 0xa2, 0xa6, 0x4c, 0xe9, 0x5f, 0x1b, 0xb0, 0xec,
	0xd2, 0xe3, 0x8c, 0xf2, 0xd4, 0x59, 0x81, 0x46, 0xce, 0x5b, 0x83, 0x05, 0xce, 0x65, 0x58, 0xaa,
	0x74, 0x2a, 0x8b, 0x23, 0x0c, 0xad, 0x03, 0x0b, 0xf8, 0x06, 0x94, 0xcc, 0xe0, 0xb8, 0x86, 0xfe,
	0x85, 0x1a, 0xfa, 0xe7, 0xa2, 0xbd, 0x78, 0x26, 0xda, 0x37, 0xa0, 0xc5, 0xc6, 0x9e, 0x4f, 0xa6,
	0xd3, 0x11, 0xf1, 0x8f, 0x54, 0xe7, 0x05, 0x6c, 0xbc, 0xad, 0x10, 0x6c, 0x2c, 0xc8, 0x74, 0xea,
	0xb1, 0x80, 0x86, 0x29, 0x4b, 0x35, 0x15, 0xb6, 0x00, 0xf7, 0x14, 0x26, 0x38, 0xd3, 0x5b, 0x14,
	0x82, 0xa6, 0xe4, 0x4c, 0x4f, 0xe4, 0xc2, 0xd7, 0x01, 0x02, 0x3a, 0x25, 0xf2, 0x05, 0x8a, 0x6f,
	0xd3, 0x05, 0xd7, 0x42, 0x44, 0xbc, 0x3d, 0xc5, 0x34, 0x1b, 0x7b, 0x3c, 0xf3, 0x7d, 0xca, 0x39,
	0xbe, 0x4d, 0x4d, 0xd7, 0x62, 0xe3, 0xa1, 0x04, 0xfa, 0xbf, 0x36, 0xc0, 0x54, 0xe1, 0xe3, 0xce,
	0x1d, 0x58, 0x48, 0xe8, 0xb1, 0xe6, 0xf9, 0x46, 0x85, 0x00, 0x2d, 0x24, 0x06, 0x8a, 0x5d, 0x14,
	0xee, 0x3d, 0x00, 0x2b, 0x87, 0x6a, 0x58, 0x7d, 0xb7, 0xca, 0xea, 0xa5, 0xba, 0x4d, 0xcb, 0x7c,
	0xfe, 0xb6, 0x29, 0x0c, 0xe2, 0x71, 0x14, 0x72, 0x2a, 0x08, 0x4c, 0xe8, 0x71, 0x71, 0x18, 0x17,
	0x13, 0x7a, 0xbc, 0x17, 0x08, 0x9f, 0x34, 0x59, 0x45, 0x17, 0xaa, 0x90, 0xbd, 0x40, 0x74, 0xe5,
	0x62, 0x55, 0xce, 0xb1, 0xed, 0x2e, 0x27, 0xf4, 0x18, 0xdf, 0xf8, 0xd7, 0x01, 0x12, 0xca, 0xbd,
	0x43, 0x4a, 0x02, 0x9a, 0xe8, 0xe6, 0x3a, 0xa1, 0xfc, 0x3e, 0x02, 0x72, 0x25, 0x97, 0x2b, 0x17,
	0xf5, 0x4a, 0x8e, 0x2b, 0xe7, 0x1b, 0x88, 0xa5, 0xb3, 0x0d, 0xc4, 0x55, 0x30, 0x39, 0x9b, 0x78,
	0xe9, 0x69, 0x4c, 0x55, 0xef, 0xb9, 0xcc, 0xd9, 0xe4, 0xe1, 0x69, 0x4c, 0x75, 0xe7, 0x60, 0x16,
	0x9d, 0xc3, 0x7c, 0xb7, 0x61, 0xc9, 0x5c, 0x2a, 0x75, 0x1b, 0xd7, 0x01, 0x68, 0x92, 0x44, 0x89,
	0x27, 0x82, 0xa5, 0xba, 0x0a, 0x0b, 0x91, 0x6d, 0xf1, 0xe8, 0xbd, 0x06, 0xf2, 0xc7, 0x9b, 0xf1,
	0x09, 0xf6, 0x13, 0x96, 0x6b, 0x22, 0xf0, 0x80, 0x4f, 0x44, 0x1e, 0x1e, 0xa6, 0x69, 0xac, 0x4b,
	0x87, 0x8d, 0x8b, 0x41, 0x40, 0xaa, 0x6e, 0x5c, 0x81, 0x25, 0xf9, 0x50, 0xec, 0xb6, 0x65, 0x57,
	0x28, 0xff, 0x9c, 0x2e, 0x2c, 0x9f, 0xd0, 0x44, 0x94, 0x84, 0xee, 0x8a, 0x74, 0x41, 0xfd, 0xf6,
	0x7f, 0x63, 0x08, 0xa2, 0x25, 0x31, 0xdc, 0x79, 0x1f, 0x16, 0x13, 0xca, 0x63, 0x9d, 0x2b, 0x37,
	0xe7, 0x68, 0x55, 0x62, 0x38, 0x52, 0xd9, 0x22, 0xe5, 0x7b, 0x9f, 0x02, 0x14, 0x60, 0x4d, 0xbe,
	0xdc, 0xae, 0xe6, 0xcb, 0xe5, 0xda, 0x8d, 0xcb, 0x09, 0xf3, 0x87, 0x06, 0xb4, 0x1f, 0x26, 0x24,
	0xe4, 0x07, 0x49, 0x94, 0x46, 0x7e, 0x34, 0x75, 0xee, 0x81, 0x15, 0xab, 0x71, 0x7d, 0xcd, 0xaa,
	0x88, 0x0f, 0xf4, 0x40, 0xd9, 0x59, 0xac, 0x75, 0x7e, 0x04, 0x40, 0xa6, 0xd3, 0xe8, 0x99, 0x60,
	0x94, 0xab, 0x4b, 0xf8, 0xdd, 0x57, 0xec, 0x74, 0x37, 0x17, 0x96, 0x5b, 0x95, 0x56, 0xf7, 0xbe,
	0x0f, 0x2b, 0x55, 0x45, 0x65, 0xdf, 0x17, 0xce, 0x79, 0x8a, 0xf4, 0x7e, 0x00, 0xab, 0x73, 0x9b,
	0x9f, 0x77, 0xef, 0x2d, 0x94, 0x63, 0xf4, 0x89, 0x2e, 0xeb, 0xdb, 0x51, 0x98, 0x26, 0xc4, 0x4f,
	0x9d, 0x37, 0xc0, 0xca, 0xfd, 0xd0, 0x9d, 0x45, 0x0e, 0x88, 0x59, 0x75, 0x9c, 0xd4, 0xf9, 0xb2,
	0xdd, 0x02, 0xe8, 0xff, 0xd2, 0x00, 0x5b, 0x35, 0x2b, 0x24, 0xe1, 0x34, 0x71, 0x7e, 0x08, 0xcb,
	0x31, 0x8e, 0x74, 0xb8, 0xab, 0x4d, 0x63, 0x59, 0x76, 0x20, 0x3f, 0x2a, 0x40, 0x7a, 0x59, 0xef,
	0x03, 0xb0, 0xcb, 0x13, 0xaf, 0xf5, 0x4c, 0xbb, 0x09, 0xd6, 0x03, 0x3e, 0xd9, 0x8f, 0xb2, 0xd0,
	0xa7, 0x42, 0x8c, 0xd3, 0xe3, 0x50, 0xbe, 0xc6, 0xda, 0xae, 0xfc, 0xe9, 0xff, 0xd9, 0x00, 0x4b,
	0x59, 0x71, 0xc4, 0x9d, 0x1d, 0x50, 0x4d, 0x92, 0x57, 0xbc, 0x26, 0x6f, 0xd5, 0x59, 0x7c, 0xc4,
	0x8b, 0x91, 0x4a, 0x8e, 0x40, 0xff, 0xf7, 0x3c, 0x58, 0xa9, 0x4e, 0xd6, 0x18, 0xfd, 0x7e, 0x35,
	0x99, 0x6f, 0xbe, 0xa4, 0xc3, 0x2d, 0x7a, 0xbe, 0x92, 0x5f, 0x5b, 0x97, 0xfe, 0xfe, 0x62, 0xcd,
	0xf8, 0xd7, 0x8b, 0x35, 0xe3, 0xdf, 0x2f, 0xd6, 0x8c, 0x2f, 0x5e, 0xac, 0x19, 0xbf, 0xfb, 0xcf,
	0xda, 0x57, 0x46, 0x4b, 0x98, 0x9e, 0x77, 0xfe, 0x17, 0x00, 0x00, 0xff, 0xff, 0xfb, 0x62, 0xf6,
	0xc4, 0xbc, 0x15, 0x00, 0x00,
}

func (m *OracleBasicInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleBasicInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleBasicInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.TotalNodeNum != 0 {
		i = encodeVarintChaincode(dAtA, i, uint64(m.TotalNodeNum))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OracleDesc) > 0 {
		i -= len(m.OracleDesc)
		copy(dAtA[i:], m.OracleDesc)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.OracleDesc)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OracleName) > 0 {
		i -= len(m.OracleName)
		copy(dAtA[i:], m.OracleName)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.OracleName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OracleBizId) > 0 {
		i -= len(m.OracleBizId)
		copy(dAtA[i:], m.OracleBizId)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.OracleBizId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OracleHashId) > 0 {
		i -= len(m.OracleHashId)
		copy(dAtA[i:], m.OracleHashId)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.OracleHashId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SGXTrustRoot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SGXTrustRoot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SGXTrustRoot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.IfPswSupport {
		i--
		if m.IfPswSupport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.MrEnclave) > 0 {
		i -= len(m.MrEnclave)
		copy(dAtA[i:], m.MrEnclave)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.MrEnclave)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RootCa) > 0 {
		i -= len(m.RootCa)
		copy(dAtA[i:], m.RootCa)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.RootCa)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.IasPubKey) > 0 {
		i -= len(m.IasPubKey)
		copy(dAtA[i:], m.IasPubKey)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.IasPubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IasDesc) > 0 {
		i -= len(m.IasDesc)
		copy(dAtA[i:], m.IasDesc)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.IasDesc)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleNodeBasicInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleNodeBasicInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleNodeBasicInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.VerifyTimestamp != 0 {
		i = encodeVarintChaincode(dAtA, i, uint64(m.VerifyTimestamp))
		i--
		dAtA[i] = 0x50
	}
	if m.CounterValue != 0 {
		i = encodeVarintChaincode(dAtA, i, uint64(m.CounterValue))
		i--
		dAtA[i] = 0x48
	}
	if len(m.CounterIdHash) > 0 {
		i -= len(m.CounterIdHash)
		copy(dAtA[i:], m.CounterIdHash)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.CounterIdHash)))
		i--
		dAtA[i] = 0x42
	}
	if m.CounterFlag != 0 {
		i = encodeVarintChaincode(dAtA, i, uint64(m.CounterFlag))
		i--
		dAtA[i] = 0x38
	}
	if len(m.EcdsaPubKey) > 0 {
		i -= len(m.EcdsaPubKey)
		copy(dAtA[i:], m.EcdsaPubKey)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.EcdsaPubKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.RsaPubKey) > 0 {
		i -= len(m.RsaPubKey)
		copy(dAtA[i:], m.RsaPubKey)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.RsaPubKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NodeDesc) > 0 {
		i -= len(m.NodeDesc)
		copy(dAtA[i:], m.NodeDesc)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.NodeDesc)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NodeBizId) > 0 {
		i -= len(m.NodeBizId)
		copy(dAtA[i:], m.NodeBizId)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.NodeBizId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeHashId) > 0 {
		i -= len(m.NodeHashId)
		copy(dAtA[i:], m.NodeHashId)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.NodeHashId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SGXProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SGXProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SGXProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RaData) > 0 {
		i -= len(m.RaData)
		copy(dAtA[i:], m.RaData)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.RaData)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IasCertChain) > 0 {
		i -= len(m.IasCertChain)
		copy(dAtA[i:], m.IasCertChain)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.IasCertChain)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AVRSig) > 0 {
		i -= len(m.AVRSig)
		copy(dAtA[i:], m.AVRSig)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.AVRSig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AVR) > 0 {
		i -= len(m.AVR)
		copy(dAtA[i:], m.AVR)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.AVR)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UDNSDomainInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UDNSDomainInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UDNSDomainInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfExists {
		i--
		if m.IfExists {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.VerifyTimestamp != 0 {
		i = encodeVarintChaincode(dAtA, i, uint64(m.VerifyTimestamp))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PubKeyHash) > 0 {
		i -= len(m.PubKeyHash)
		copy(dAtA[i:], m.PubKeyHash)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.PubKeyHash)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SigningBody) > 0 {
		i -= len(m.SigningBody)
		copy(dAtA[i:], m.SigningBody)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.SigningBody)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.UdnsEcdsaPubKey) > 0 {
		i -= len(m.UdnsEcdsaPubKey)
		copy(dAtA[i:], m.UdnsEcdsaPubKey)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.UdnsEcdsaPubKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.UdnsRsaPubKey) > 0 {
		i -= len(m.UdnsRsaPubKey)
		copy(dAtA[i:], m.UdnsRsaPubKey)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.UdnsRsaPubKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DomainCert) > 0 {
		i -= len(m.DomainCert)
		copy(dAtA[i:], m.DomainCert)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.DomainCert)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.UdnsCert) > 0 {
		i -= len(m.UdnsCert)
		copy(dAtA[i:], m.UdnsCert)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.UdnsCert)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DomainName) > 0 {
		i -= len(m.DomainName)
		copy(dAtA[i:], m.DomainName)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.DomainName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DomainHashId) > 0 {
		i -= len(m.DomainHashId)
		copy(dAtA[i:], m.DomainHashId)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.DomainHashId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UDNSInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UDNSInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UDNSInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UdnsDomains) > 0 {
		keysForUdnsDomains := make([]string, 0, len(m.UdnsDomains))
		for k := range m.UdnsDomains {
			keysForUdnsDomains = append(keysForUdnsDomains, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForUdnsDomains)
		for iNdEx := len(keysForUdnsDomains) - 1; iNdEx >= 0; iNdEx-- {
			v := m.UdnsDomains[string(keysForUdnsDomains[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintChaincode(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForUdnsDomains[iNdEx])
			copy(dAtA[i:], keysForUdnsDomains[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForUdnsDomains[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.DomainIdList) > 0 {
		for iNdEx := len(m.DomainIdList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DomainIdList[iNdEx])
			copy(dAtA[i:], m.DomainIdList[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(m.DomainIdList[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TotalDomainNum != 0 {
		i = encodeVarintChaincode(dAtA, i, uint64(m.TotalDomainNum))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UdnsCaPubKey) > 0 {
		i -= len(m.UdnsCaPubKey)
		copy(dAtA[i:], m.UdnsCaPubKey)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.UdnsCaPubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SGXOracleNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SGXOracleNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SGXOracleNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UdnsInfo != nil {
		{
			size, err := m.UdnsInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChaincode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SgxProof != nil {
		{
			size, err := m.SgxProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChaincode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.OracleNodeBasicInfo != nil {
		{
			size, err := m.OracleNodeBasicInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChaincode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UDNSDomainPKHashInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UDNSDomainPKHashInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UDNSDomainPKHashInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DomainName) > 0 {
		i -= len(m.DomainName)
		copy(dAtA[i:], m.DomainName)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.DomainName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeBizId) > 0 {
		i -= len(m.NodeBizId)
		copy(dAtA[i:], m.NodeBizId)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.NodeBizId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SGXOracleCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SGXOracleCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SGXOracleCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OracleNodes) > 0 {
		keysForOracleNodes := make([]string, 0, len(m.OracleNodes))
		for k := range m.OracleNodes {
			keysForOracleNodes = append(keysForOracleNodes, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForOracleNodes)
		for iNdEx := len(keysForOracleNodes) - 1; iNdEx >= 0; iNdEx-- {
			v := m.OracleNodes[string(keysForOracleNodes[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintChaincode(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForOracleNodes[iNdEx])
			copy(dAtA[i:], keysForOracleNodes[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForOracleNodes[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.NodeBizIdList) > 0 {
		for iNdEx := len(m.NodeBizIdList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NodeBizIdList[iNdEx])
			copy(dAtA[i:], m.NodeBizIdList[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(m.NodeBizIdList[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.SgxTrustRoot != nil {
		{
			size, err := m.SgxTrustRoot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChaincode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.OracleBasicInfo != nil {
		{
			size, err := m.OracleBasicInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChaincode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SGXOracleClusters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SGXOracleClusters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SGXOracleClusters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Clusters) > 0 {
		keysForClusters := make([]string, 0, len(m.Clusters))
		for k := range m.Clusters {
			keysForClusters = append(keysForClusters, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForClusters)
		for iNdEx := len(keysForClusters) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Clusters[string(keysForClusters[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintChaincode(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForClusters[iNdEx])
			copy(dAtA[i:], keysForClusters[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForClusters[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Counters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Counters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Counters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Counters) > 0 {
		keysForCounters := make([]string, 0, len(m.Counters))
		for k := range m.Counters {
			keysForCounters = append(keysForCounters, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForCounters)
		for iNdEx := len(keysForCounters) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Counters[string(keysForCounters[iNdEx])]
			baseI := i
			i = encodeVarintChaincode(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(keysForCounters[iNdEx])
			copy(dAtA[i:], keysForCounters[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForCounters[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OracleNodePks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleNodePks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleNodePks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pks) > 0 {
		keysForPks := make([]string, 0, len(m.Pks))
		for k := range m.Pks {
			keysForPks = append(keysForPks, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForPks)
		for iNdEx := len(keysForPks) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Pks[string(keysForPks[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintChaincode(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForPks[iNdEx])
			copy(dAtA[i:], keysForPks[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForPks[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OracleService) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleService) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleService) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PermissionBlacklist) > 0 {
		keysForPermissionBlacklist := make([]string, 0, len(m.PermissionBlacklist))
		for k := range m.PermissionBlacklist {
			keysForPermissionBlacklist = append(keysForPermissionBlacklist, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForPermissionBlacklist)
		for iNdEx := len(keysForPermissionBlacklist) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PermissionBlacklist[string(keysForPermissionBlacklist[iNdEx])]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i -= len(keysForPermissionBlacklist[iNdEx])
			copy(dAtA[i:], keysForPermissionBlacklist[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForPermissionBlacklist[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PermissionWhitelist) > 0 {
		keysForPermissionWhitelist := make([]string, 0, len(m.PermissionWhitelist))
		for k := range m.PermissionWhitelist {
			keysForPermissionWhitelist = append(keysForPermissionWhitelist, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForPermissionWhitelist)
		for iNdEx := len(keysForPermissionWhitelist) - 1; iNdEx >= 0; iNdEx-- {
			v := m.PermissionWhitelist[string(keysForPermissionWhitelist[iNdEx])]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i -= len(keysForPermissionWhitelist[iNdEx])
			copy(dAtA[i:], keysForPermissionWhitelist[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForPermissionWhitelist[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.OracleServiceBasicInfo != nil {
		{
			size, err := m.OracleServiceBasicInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChaincode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleServiceBasicInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleServiceBasicInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleServiceBasicInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PermissionPolicy) > 0 {
		i -= len(m.PermissionPolicy)
		copy(dAtA[i:], m.PermissionPolicy)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.PermissionPolicy)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DataSource) > 0 {
		i -= len(m.DataSource)
		copy(dAtA[i:], m.DataSource)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.DataSource)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ServiceStatus) > 0 {
		i -= len(m.ServiceStatus)
		copy(dAtA[i:], m.ServiceStatus)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.ServiceStatus)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OracleBizId) > 0 {
		i -= len(m.OracleBizId)
		copy(dAtA[i:], m.OracleBizId)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.OracleBizId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServiceDesc) > 0 {
		i -= len(m.ServiceDesc)
		copy(dAtA[i:], m.ServiceDesc)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.ServiceDesc)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ServiceBizId) > 0 {
		i -= len(m.ServiceBizId)
		copy(dAtA[i:], m.ServiceBizId)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.ServiceBizId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OracleServices) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleServices) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleServices) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Services) > 0 {
		keysForServices := make([]string, 0, len(m.Services))
		for k := range m.Services {
			keysForServices = append(keysForServices, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForServices)
		for iNdEx := len(keysForServices) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Services[string(keysForServices[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintChaincode(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForServices[iNdEx])
			copy(dAtA[i:], keysForServices[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForServices[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IfSuccess {
		i--
		if m.IfSuccess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.DelayTime != 0 {
		i = encodeVarintChaincode(dAtA, i, uint64(m.DelayTime))
		i--
		dAtA[i] = 0x48
	}
	if len(m.CallbackIdentity) > 0 {
		i -= len(m.CallbackIdentity)
		copy(dAtA[i:], m.CallbackIdentity)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.CallbackIdentity)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.CallIdentity) > 0 {
		i -= len(m.CallIdentity)
		copy(dAtA[i:], m.CallIdentity)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.CallIdentity)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IfCallback {
		i--
		if m.IfCallback {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.DataSource) > 0 {
		i -= len(m.DataSource)
		copy(dAtA[i:], m.DataSource)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.DataSource)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ServiceBizId) > 0 {
		i -= len(m.ServiceBizId)
		copy(dAtA[i:], m.ServiceBizId)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.ServiceBizId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BizId) > 0 {
		i -= len(m.BizId)
		copy(dAtA[i:], m.BizId)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.BizId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Requests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Requests) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Requests) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reqs) > 0 {
		keysForReqs := make([]string, 0, len(m.Reqs))
		for k := range m.Reqs {
			keysForReqs = append(keysForReqs, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForReqs)
		for iNdEx := len(keysForReqs) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Reqs[string(keysForReqs[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintChaincode(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForReqs[iNdEx])
			copy(dAtA[i:], keysForReqs[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForReqs[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Version != 0 {
		i = encodeVarintChaincode(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x70
	}
	if len(m.Domain) > 0 {
		i -= len(m.Domain)
		copy(dAtA[i:], m.Domain)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.Domain)))
		i--
		dAtA[i] = 0x6a
	}
	if m.HttpStatus != 0 {
		i = encodeVarintChaincode(dAtA, i, uint64(m.HttpStatus))
		i--
		dAtA[i] = 0x60
	}
	if len(m.ErrorMsg) > 0 {
		i -= len(m.ErrorMsg)
		copy(dAtA[i:], m.ErrorMsg)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.ErrorMsg)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintChaincode(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x50
	}
	if len(m.PubKeyHash) > 0 {
		i -= len(m.PubKeyHash)
		copy(dAtA[i:], m.PubKeyHash)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.PubKeyHash)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x42
	}
	if m.SigType != 0 {
		i = encodeVarintChaincode(dAtA, i, uint64(m.SigType))
		i--
		dAtA[i] = 0x38
	}
	if len(m.SigningBody) > 0 {
		i -= len(m.SigningBody)
		copy(dAtA[i:], m.SigningBody)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.SigningBody)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ResBody) > 0 {
		i -= len(m.ResBody)
		copy(dAtA[i:], m.ResBody)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.ResBody)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ResHeader) > 0 {
		i -= len(m.ResHeader)
		copy(dAtA[i:], m.ResHeader)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.ResHeader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ReqBody) > 0 {
		i -= len(m.ReqBody)
		copy(dAtA[i:], m.ReqBody)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.ReqBody)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Responses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Responses) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Responses) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Resps) > 0 {
		keysForResps := make([]string, 0, len(m.Resps))
		for k := range m.Resps {
			keysForResps = append(keysForResps, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForResps)
		for iNdEx := len(keysForResps) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Resps[string(keysForResps[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintChaincode(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForResps[iNdEx])
			copy(dAtA[i:], keysForResps[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForResps[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TransProtocol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransProtocol) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransProtocol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Allowtypes) > 0 {
		keysForAllowtypes := make([]string, 0, len(m.Allowtypes))
		for k := range m.Allowtypes {
			keysForAllowtypes = append(keysForAllowtypes, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForAllowtypes)
		for iNdEx := len(keysForAllowtypes) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Allowtypes[string(keysForAllowtypes[iNdEx])]
			baseI := i
			i = encodeVarintChaincode(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(keysForAllowtypes[iNdEx])
			copy(dAtA[i:], keysForAllowtypes[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForAllowtypes[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Protocols) > 0 {
		keysForProtocols := make([]uint64, 0, len(m.Protocols))
		for k := range m.Protocols {
			keysForProtocols = append(keysForProtocols, uint64(k))
		}
		github_com_gogo_protobuf_sortkeys.Uint64s(keysForProtocols)
		for iNdEx := len(keysForProtocols) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Protocols[uint64(keysForProtocols[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintChaincode(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintChaincode(dAtA, i, uint64(keysForProtocols[iNdEx]))
			i--
			dAtA[i] = 0x8
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OracleContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OracleContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OracleContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Serviceid) > 0 {
		i -= len(m.Serviceid)
		copy(dAtA[i:], m.Serviceid)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.Serviceid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Chaincode) > 0 {
		i -= len(m.Chaincode)
		copy(dAtA[i:], m.Chaincode)
		i = encodeVarintChaincode(dAtA, i, uint64(len(m.Chaincode)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DomainParser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainParser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainParser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Parsers) > 0 {
		keysForParsers := make([]string, 0, len(m.Parsers))
		for k := range m.Parsers {
			keysForParsers = append(keysForParsers, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForParsers)
		for iNdEx := len(keysForParsers) - 1; iNdEx >= 0; iNdEx-- {
			v := m.Parsers[string(keysForParsers[iNdEx])]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintChaincode(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(keysForParsers[iNdEx])
			copy(dAtA[i:], keysForParsers[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForParsers[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgNounce) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNounce) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNounce) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Seqno != 0 {
		i = encodeVarintChaincode(dAtA, i, uint64(m.Seqno))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DomainPks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainPks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainPks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DomainPks) > 0 {
		keysForDomainPks := make([]string, 0, len(m.DomainPks))
		for k := range m.DomainPks {
			keysForDomainPks = append(keysForDomainPks, string(k))
		}
		github_com_gogo_protobuf_sortkeys.Strings(keysForDomainPks)
		for iNdEx := len(keysForDomainPks) - 1; iNdEx >= 0; iNdEx-- {
			v := m.DomainPks[string(keysForDomainPks[iNdEx])]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintChaincode(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(keysForDomainPks[iNdEx])
			copy(dAtA[i:], keysForDomainPks[iNdEx])
			i = encodeVarintChaincode(dAtA, i, uint64(len(keysForDomainPks[iNdEx])))
			i--
			dAtA[i] = 0xa
			i = encodeVarintChaincode(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintChaincode(dAtA []byte, offset int, v uint64) int {
	offset -= sovChaincode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OracleBasicInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OracleHashId)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.OracleBizId)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.OracleName)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.OracleDesc)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.TotalNodeNum != 0 {
		n += 1 + sovChaincode(uint64(m.TotalNodeNum))
	}
	if m.IfExists {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SGXTrustRoot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IasDesc)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.IasPubKey)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.RootCa)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.MrEnclave)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.IfPswSupport {
		n += 2
	}
	if m.IfExists {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OracleNodeBasicInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeHashId)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.NodeBizId)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.NodeDesc)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.RsaPubKey)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.EcdsaPubKey)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.CounterFlag != 0 {
		n += 1 + sovChaincode(uint64(m.CounterFlag))
	}
	l = len(m.CounterIdHash)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.CounterValue != 0 {
		n += 1 + sovChaincode(uint64(m.CounterValue))
	}
	if m.VerifyTimestamp != 0 {
		n += 1 + sovChaincode(uint64(m.VerifyTimestamp))
	}
	if m.IfExists {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SGXProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AVR)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.AVRSig)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.IasCertChain)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.RaData)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UDNSDomainInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DomainHashId)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.DomainName)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.UdnsCert)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.DomainCert)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.UdnsRsaPubKey)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.UdnsEcdsaPubKey)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.SigningBody)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.PubKeyHash)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.VerifyTimestamp != 0 {
		n += 1 + sovChaincode(uint64(m.VerifyTimestamp))
	}
	if m.IfExists {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UDNSInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UdnsCaPubKey)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.TotalDomainNum != 0 {
		n += 1 + sovChaincode(uint64(m.TotalDomainNum))
	}
	if len(m.DomainIdList) > 0 {
		for _, s := range m.DomainIdList {
			l = len(s)
			n += 1 + l + sovChaincode(uint64(l))
		}
	}
	if len(m.UdnsDomains) > 0 {
		for k, v := range m.UdnsDomains {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovChaincode(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SGXOracleNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OracleNodeBasicInfo != nil {
		l = m.OracleNodeBasicInfo.Size()
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.SgxProof != nil {
		l = m.SgxProof.Size()
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.UdnsInfo != nil {
		l = m.UdnsInfo.Size()
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UDNSDomainPKHashInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeBizId)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.DomainName)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SGXOracleCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OracleBasicInfo != nil {
		l = m.OracleBasicInfo.Size()
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.SgxTrustRoot != nil {
		l = m.SgxTrustRoot.Size()
		n += 1 + l + sovChaincode(uint64(l))
	}
	if len(m.NodeBizIdList) > 0 {
		for _, s := range m.NodeBizIdList {
			l = len(s)
			n += 1 + l + sovChaincode(uint64(l))
		}
	}
	if len(m.OracleNodes) > 0 {
		for k, v := range m.OracleNodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovChaincode(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SGXOracleClusters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Clusters) > 0 {
		for k, v := range m.Clusters {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovChaincode(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Counters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Counters) > 0 {
		for k, v := range m.Counters {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + 1 + sovChaincode(uint64(v))
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OracleNodePks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pks) > 0 {
		for k, v := range m.Pks {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + 1 + len(v) + sovChaincode(uint64(len(v)))
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OracleService) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OracleServiceBasicInfo != nil {
		l = m.OracleServiceBasicInfo.Size()
		n += 1 + l + sovChaincode(uint64(l))
	}
	if len(m.PermissionWhitelist) > 0 {
		for k, v := range m.PermissionWhitelist {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if len(m.PermissionBlacklist) > 0 {
		for k, v := range m.PermissionBlacklist {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OracleServiceBasicInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceBizId)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.ServiceDesc)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.OracleBizId)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.ServiceStatus)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.DataSource)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.PermissionPolicy)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OracleServices) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Services) > 0 {
		for k, v := range m.Services {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovChaincode(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.BizId)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.ServiceBizId)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.DataSource)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.IfCallback {
		n += 2
	}
	l = len(m.CallIdentity)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.CallbackIdentity)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.DelayTime != 0 {
		n += 1 + sovChaincode(uint64(m.DelayTime))
	}
	if m.IfSuccess {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Requests) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Reqs) > 0 {
		for k, v := range m.Reqs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovChaincode(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.ReqBody)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.ResHeader)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.ResBody)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.SigningBody)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.SigType != 0 {
		n += 1 + sovChaincode(uint64(m.SigType))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.PubKeyHash)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovChaincode(uint64(m.ErrorCode))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.HttpStatus != 0 {
		n += 1 + sovChaincode(uint64(m.HttpStatus))
	}
	l = len(m.Domain)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovChaincode(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Responses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resps) > 0 {
		for k, v := range m.Resps {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovChaincode(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransProtocol) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Protocols) > 0 {
		for k, v := range m.Protocols {
			_ = k
			_ = v
			mapEntrySize := 1 + sovChaincode(uint64(k)) + 1 + len(v) + sovChaincode(uint64(len(v)))
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if len(m.Allowtypes) > 0 {
		for k, v := range m.Allowtypes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + 1 + sovChaincode(uint64(v))
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OracleContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chaincode)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	l = len(m.Serviceid)
	if l > 0 {
		n += 1 + l + sovChaincode(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DomainParser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parsers) > 0 {
		for k, v := range m.Parsers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + 1 + len(v) + sovChaincode(uint64(len(v)))
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgNounce) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seqno != 0 {
		n += 1 + sovChaincode(uint64(m.Seqno))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DomainPks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DomainPks) > 0 {
		for k, v := range m.DomainPks {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovChaincode(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovChaincode(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovChaincode(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovChaincode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChaincode(x uint64) (n int) {
	return sovChaincode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OracleBasicInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleBasicInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleBasicInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleHashId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleHashId = append(m.OracleHashId[:0], dAtA[iNdEx:postIndex]...)
			if m.OracleHashId == nil {
				m.OracleHashId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBizId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleBizId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNodeNum", wireType)
			}
			m.TotalNodeNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNodeNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SGXTrustRoot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SGXTrustRoot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SGXTrustRoot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IasDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IasDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IasPubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IasPubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootCa", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootCa = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MrEnclave", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MrEnclave = append(m.MrEnclave[:0], dAtA[iNdEx:postIndex]...)
			if m.MrEnclave == nil {
				m.MrEnclave = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfPswSupport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfPswSupport = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleNodeBasicInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleNodeBasicInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleNodeBasicInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeHashId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeHashId = append(m.NodeHashId[:0], dAtA[iNdEx:postIndex]...)
			if m.NodeHashId == nil {
				m.NodeHashId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeBizId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeBizId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RsaPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RsaPubKey = append(m.RsaPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.RsaPubKey == nil {
				m.RsaPubKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcdsaPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EcdsaPubKey = append(m.EcdsaPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EcdsaPubKey == nil {
				m.EcdsaPubKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterFlag", wireType)
			}
			m.CounterFlag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CounterFlag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterIdHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterIdHash = append(m.CounterIdHash[:0], dAtA[iNdEx:postIndex]...)
			if m.CounterIdHash == nil {
				m.CounterIdHash = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterValue", wireType)
			}
			m.CounterValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CounterValue |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyTimestamp", wireType)
			}
			m.VerifyTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifyTimestamp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SGXProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SGXProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SGXProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AVR", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AVR = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AVRSig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AVRSig = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IasCertChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IasCertChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UDNSDomainInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UDNSDomainInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UDNSDomainInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainHashId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainHashId = append(m.DomainHashId[:0], dAtA[iNdEx:postIndex]...)
			if m.DomainHashId == nil {
				m.DomainHashId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdnsCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UdnsCert = append(m.UdnsCert[:0], dAtA[iNdEx:postIndex]...)
			if m.UdnsCert == nil {
				m.UdnsCert = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainCert = append(m.DomainCert[:0], dAtA[iNdEx:postIndex]...)
			if m.DomainCert == nil {
				m.DomainCert = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdnsRsaPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UdnsRsaPubKey = append(m.UdnsRsaPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UdnsRsaPubKey == nil {
				m.UdnsRsaPubKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdnsEcdsaPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UdnsEcdsaPubKey = append(m.UdnsEcdsaPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UdnsEcdsaPubKey == nil {
				m.UdnsEcdsaPubKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigningBody = append(m.SigningBody[:0], dAtA[iNdEx:postIndex]...)
			if m.SigningBody == nil {
				m.SigningBody = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKeyHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKeyHash = append(m.PubKeyHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKeyHash == nil {
				m.PubKeyHash = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyTimestamp", wireType)
			}
			m.VerifyTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifyTimestamp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfExists", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfExists = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UDNSInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UDNSInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UDNSInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdnsCaPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UdnsCaPubKey = append(m.UdnsCaPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UdnsCaPubKey == nil {
				m.UdnsCaPubKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDomainNum", wireType)
			}
			m.TotalDomainNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDomainNum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainIdList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainIdList = append(m.DomainIdList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdnsDomains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UdnsDomains == nil {
				m.UdnsDomains = make(map[string]*UDNSDomainInfo)
			}
			var mapkey string
			var mapvalue *UDNSDomainInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthChaincode
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthChaincode
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &UDNSDomainInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UdnsDomains[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SGXOracleNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SGXOracleNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SGXOracleNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleNodeBasicInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OracleNodeBasicInfo == nil {
				m.OracleNodeBasicInfo = &OracleNodeBasicInfo{}
			}
			if err := m.OracleNodeBasicInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SgxProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SgxProof == nil {
				m.SgxProof = &SGXProof{}
			}
			if err := m.SgxProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdnsInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UdnsInfo == nil {
				m.UdnsInfo = &UDNSInfo{}
			}
			if err := m.UdnsInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UDNSDomainPKHashInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UDNSDomainPKHashInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UDNSDomainPKHashInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeBizId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeBizId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DomainName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SGXOracleCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SGXOracleCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SGXOracleCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBasicInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OracleBasicInfo == nil {
				m.OracleBasicInfo = &OracleBasicInfo{}
			}
			if err := m.OracleBasicInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SgxTrustRoot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SgxTrustRoot == nil {
				m.SgxTrustRoot = &SGXTrustRoot{}
			}
			if err := m.SgxTrustRoot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeBizIdList", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeBizIdList = append(m.NodeBizIdList, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OracleNodes == nil {
				m.OracleNodes = make(map[string]*SGXOracleNode)
			}
			var mapkey string
			var mapvalue *SGXOracleNode
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthChaincode
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthChaincode
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SGXOracleNode{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.OracleNodes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SGXOracleClusters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SGXOracleClusters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SGXOracleClusters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Clusters == nil {
				m.Clusters = make(map[string]*SGXOracleCluster)
			}
			var mapkey string
			var mapvalue *SGXOracleCluster
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthChaincode
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthChaincode
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &SGXOracleCluster{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Clusters[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Counters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Counters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Counters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Counters == nil {
				m.Counters = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Counters[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleNodePks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleNodePks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleNodePks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pks == nil {
				m.Pks = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Pks[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleService) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleService: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleService: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleServiceBasicInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OracleServiceBasicInfo == nil {
				m.OracleServiceBasicInfo = &OracleServiceBasicInfo{}
			}
			if err := m.OracleServiceBasicInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermissionWhitelist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermissionWhitelist == nil {
				m.PermissionWhitelist = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PermissionWhitelist[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermissionBlacklist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PermissionBlacklist == nil {
				m.PermissionBlacklist = make(map[string]bool)
			}
			var mapkey string
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PermissionBlacklist[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleServiceBasicInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleServiceBasicInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleServiceBasicInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceBizId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceBizId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceDesc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceDesc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleBizId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleBizId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermissionPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PermissionPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleServices) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleServices: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleServices: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Services == nil {
				m.Services = make(map[string]*OracleService)
			}
			var mapkey string
			var mapvalue *OracleService
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthChaincode
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthChaincode
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &OracleService{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Services[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BizId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BizId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceBizId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceBizId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataSource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfCallback", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfCallback = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallIdentity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallIdentity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallbackIdentity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallbackIdentity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayTime", wireType)
			}
			m.DelayTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfSuccess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfSuccess = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Requests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Requests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Requests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reqs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reqs == nil {
				m.Reqs = make(map[string]*Request)
			}
			var mapkey string
			var mapvalue *Request
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthChaincode
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthChaincode
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Request{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Reqs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqBody = append(m.ReqBody[:0], dAtA[iNdEx:postIndex]...)
			if m.ReqBody == nil {
				m.ReqBody = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResHeader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResHeader = append(m.ResHeader[:0], dAtA[iNdEx:postIndex]...)
			if m.ResHeader == nil {
				m.ResHeader = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResBody = append(m.ResBody[:0], dAtA[iNdEx:postIndex]...)
			if m.ResBody == nil {
				m.ResBody = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigningBody = append(m.SigningBody[:0], dAtA[iNdEx:postIndex]...)
			if m.SigningBody == nil {
				m.SigningBody = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigType", wireType)
			}
			m.SigType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKeyHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKeyHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpStatus", wireType)
			}
			m.HttpStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpStatus |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Responses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Responses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Responses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resps == nil {
				m.Resps = make(map[string]*Response)
			}
			var mapkey string
			var mapvalue *Response
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthChaincode
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthChaincode
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Response{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Resps[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransProtocol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransProtocol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransProtocol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Protocols == nil {
				m.Protocols = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Protocols[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allowtypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Allowtypes == nil {
				m.Allowtypes = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Allowtypes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OracleContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OracleContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OracleContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chaincode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chaincode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Serviceid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Serviceid = append(m.Serviceid[:0], dAtA[iNdEx:postIndex]...)
			if m.Serviceid == nil {
				m.Serviceid = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainParser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainParser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainParser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parsers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parsers == nil {
				m.Parsers = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Parsers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNounce) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNounce: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNounce: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seqno", wireType)
			}
			m.Seqno = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seqno |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainPks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainPks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainPks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DomainPks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChaincode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChaincode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DomainPks == nil {
				m.DomainPks = make(map[string]*UDNSDomainPKHashInfo)
			}
			var mapkey string
			var mapvalue *UDNSDomainPKHashInfo
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowChaincode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthChaincode
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowChaincode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthChaincode
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthChaincode
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &UDNSDomainPKHashInfo{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipChaincode(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthChaincode
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DomainPks[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChaincode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChaincode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChaincode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChaincode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChaincode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChaincode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChaincode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChaincode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChaincode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChaincode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChaincode = fmt.Errorf("proto: unexpected end of group")
)
