// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_ANT_GENERATED_AUTHMESSAGE_CROSSCHAIN_AUTHMSGSPACE_H_
#define FLATBUFFERS_ANT_GENERATED_AUTHMESSAGE_CROSSCHAIN_AUTHMSGSPACE_H_

#include "flatbuffers/flatbuffers.h"
#include "mybuffer/mybuffer.h"
#include "auth_message_generated.h"
#include <mychainlib/contract.h>
using namespace mychain;

namespace Crosschain {
namespace AuthMsgSpace {

struct AuthMsgSchemaM;
typedef flatbuffers::Offset<AuthMsgSchema> AuthMsgSchemaMOffset;
typedef std::shared_ptr<AuthMsgSchemaM> AuthMsgSchemaMPtr;
typedef std::shared_ptr<MyVector<AuthMsgSchemaM, AuthMsgSchemaT> > AuthMsgSchemaMVectorPtr;
typedef std::shared_ptr<MyMap<AuthMsgSchemaM> > AuthMsgSchemaMMapPtr;
typedef std::shared_ptr<MyMapIterable<AuthMsgSchemaM> > AuthMsgSchemaMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<AuthMsgSchemaM> > AuthMsgSchemaMMapKeyIterator;

struct CachedMsgM;
typedef flatbuffers::Offset<CachedMsg> CachedMsgMOffset;
typedef std::shared_ptr<CachedMsgM> CachedMsgMPtr;
typedef std::shared_ptr<MyVector<CachedMsgM, CachedMsgT> > CachedMsgMVectorPtr;
typedef std::shared_ptr<MyMap<CachedMsgM> > CachedMsgMMapPtr;
typedef std::shared_ptr<MyMapIterable<CachedMsgM> > CachedMsgMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<CachedMsgM> > CachedMsgMMapKeyIterator;

struct AuthenticM;
typedef flatbuffers::Offset<Authentic> AuthenticMOffset;
typedef std::shared_ptr<AuthenticM> AuthenticMPtr;
typedef std::shared_ptr<MyVector<AuthenticM, AuthenticT> > AuthenticMVectorPtr;
typedef std::shared_ptr<MyMap<AuthenticM> > AuthenticMMapPtr;
typedef std::shared_ptr<MyMapIterable<AuthenticM> > AuthenticMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<AuthenticM> > AuthenticMMapKeyIterator;

struct RelayerInfoM;
typedef flatbuffers::Offset<RelayerInfo> RelayerInfoMOffset;
typedef std::shared_ptr<RelayerInfoM> RelayerInfoMPtr;
typedef std::shared_ptr<MyVector<RelayerInfoM, RelayerInfoT> > RelayerInfoMVectorPtr;
typedef std::shared_ptr<MyMap<RelayerInfoM> > RelayerInfoMMapPtr;
typedef std::shared_ptr<MyMapIterable<RelayerInfoM> > RelayerInfoMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<RelayerInfoM> > RelayerInfoMMapKeyIterator;

struct RelayerIdentityM;
typedef flatbuffers::Offset<RelayerIdentity> RelayerIdentityMOffset;
typedef std::shared_ptr<RelayerIdentityM> RelayerIdentityMPtr;
typedef std::shared_ptr<MyVector<RelayerIdentityM, RelayerIdentityT> > RelayerIdentityMVectorPtr;
typedef std::shared_ptr<MyMap<RelayerIdentityM> > RelayerIdentityMMapPtr;
typedef std::shared_ptr<MyMapIterable<RelayerIdentityM> > RelayerIdentityMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<RelayerIdentityM> > RelayerIdentityMMapKeyIterator;

struct ProtocolInfoM;
typedef flatbuffers::Offset<ProtocolInfo> ProtocolInfoMOffset;
typedef std::shared_ptr<ProtocolInfoM> ProtocolInfoMPtr;
typedef std::shared_ptr<MyVector<ProtocolInfoM, ProtocolInfoT> > ProtocolInfoMVectorPtr;
typedef std::shared_ptr<MyMap<ProtocolInfoM> > ProtocolInfoMMapPtr;
typedef std::shared_ptr<MyMapIterable<ProtocolInfoM> > ProtocolInfoMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<ProtocolInfoM> > ProtocolInfoMMapKeyIterator;

struct RouteInfoM;
typedef flatbuffers::Offset<RouteInfo> RouteInfoMOffset;
typedef std::shared_ptr<RouteInfoM> RouteInfoMPtr;
typedef std::shared_ptr<MyVector<RouteInfoM, RouteInfoT> > RouteInfoMVectorPtr;
typedef std::shared_ptr<MyMap<RouteInfoM> > RouteInfoMMapPtr;
typedef std::shared_ptr<MyMapIterable<RouteInfoM> > RouteInfoMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<RouteInfoM> > RouteInfoMMapKeyIterator;

struct DomainParseInfoM;
typedef flatbuffers::Offset<DomainParseInfo> DomainParseInfoMOffset;
typedef std::shared_ptr<DomainParseInfoM> DomainParseInfoMPtr;
typedef std::shared_ptr<MyVector<DomainParseInfoM, DomainParseInfoT> > DomainParseInfoMVectorPtr;
typedef std::shared_ptr<MyMap<DomainParseInfoM> > DomainParseInfoMMapPtr;
typedef std::shared_ptr<MyMapIterable<DomainParseInfoM> > DomainParseInfoMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<DomainParseInfoM> > DomainParseInfoMMapKeyIterator;

struct AuthMsgSchemaM : public MyTable<AuthMsgSchemaT, AuthMsgSchema> {
private: 
  std::weak_ptr<MyMap<AuthenticM> > contract_admins_;
  std::weak_ptr<MyMap<RelayerInfoM> > allowed_relayers_;
  std::weak_ptr<MyVector<RelayerIdentityM, RelayerIdentityT> > relayer_list_;
  std::weak_ptr<MyMap<ProtocolInfoM> > allowed_protocols_;
  std::weak_ptr<MyMap<RouteInfoM> > protocol_routes_;
  std::weak_ptr<MyMap<DomainParseInfoM> > domain_parse_info_;
  std::weak_ptr<MyMap<CachedMsgM> > cached_auth_msgs_;
  using MyTable<AuthMsgSchemaT, AuthMsgSchema>::MyTable;
  friend class MyFactory<AuthMsgSchemaM, AuthMsgSchemaT>;
  friend class MyFactory<AuthMsgSchemaM>;
public: 
  ~AuthMsgSchemaM() {}
  AuthenticMMapPtr get_contract_admins() {
    AuthenticMMapPtr rv;
    rv = contract_admins_.lock();
    if (!rv) {
      rv = MyFactory<MyMap<AuthenticM> >::make_instance(ComposeKey(base_key_, "contract_admins"), get_self_ptr());
      contract_admins_ = rv;
    }
    return rv;
  }
  RelayerInfoMMapPtr get_allowed_relayers() {
    RelayerInfoMMapPtr rv;
    rv = allowed_relayers_.lock();
    if (!rv) {
      rv = MyFactory<MyMap<RelayerInfoM> >::make_instance(ComposeKey(base_key_, "allowed_relayers"), get_self_ptr());
      allowed_relayers_ = rv;
    }
    return rv;
  }
  RelayerIdentityMVectorPtr get_relayer_list() {
    RelayerIdentityMVectorPtr rv;
    rv = relayer_list_.lock();
    if (!rv) {
      rv = MyFactory<MyVector<RelayerIdentityM, RelayerIdentityT>, RelayerIdentityT>::make_instance(native_table_ptr_->relayer_list, get_self_ptr());
      relayer_list_ = rv;
    }
    return rv;
  }
  ProtocolInfoMMapPtr get_allowed_protocols() {
    ProtocolInfoMMapPtr rv;
    rv = allowed_protocols_.lock();
    if (!rv) {
      rv = MyFactory<MyMap<ProtocolInfoM> >::make_instance(ComposeKey(base_key_, "allowed_protocols"), get_self_ptr());
      allowed_protocols_ = rv;
    }
    return rv;
  }
  RouteInfoMMapPtr get_protocol_routes() {
    RouteInfoMMapPtr rv;
    rv = protocol_routes_.lock();
    if (!rv) {
      rv = MyFactory<MyMap<RouteInfoM> >::make_instance(ComposeKey(base_key_, "protocol_routes"), get_self_ptr());
      protocol_routes_ = rv;
    }
    return rv;
  }
  DomainParseInfoMMapPtr get_domain_parse_info() {
    DomainParseInfoMMapPtr rv;
    rv = domain_parse_info_.lock();
    if (!rv) {
      rv = MyFactory<MyMap<DomainParseInfoM> >::make_instance(ComposeKey(base_key_, "domain_parse_info"), get_self_ptr());
      domain_parse_info_ = rv;
    }
    return rv;
  }
  std::string get_myoracle_contract() {
    return native_table_ptr_->myoracle_contract;
  }
  bool set_myoracle_contract(std::string _myoracle_contract) {
    if( _myoracle_contract.length() > kMaxStringValLen ) {
        Revert("The string size is over limit.");
    }
    set_dirty(true);
    native_table_ptr_->myoracle_contract = std::move(_myoracle_contract);
    return true;
  }
  std::string get_myoracle_service() {
    return native_table_ptr_->myoracle_service;
  }
  bool set_myoracle_service(std::string _myoracle_service) {
    if( _myoracle_service.length() > kMaxStringValLen ) {
        Revert("The string size is over limit.");
    }
    set_dirty(true);
    native_table_ptr_->myoracle_service = std::move(_myoracle_service);
    return true;
  }
  CachedMsgMMapPtr get_cached_auth_msgs() {
    CachedMsgMMapPtr rv;
    rv = cached_auth_msgs_.lock();
    if (!rv) {
      rv = MyFactory<MyMap<CachedMsgM> >::make_instance(ComposeKey(base_key_, "cached_auth_msgs"), get_self_ptr());
      cached_auth_msgs_ = rv;
    }
    return rv;
  }
};

struct CachedMsgM : public MyTable<CachedMsgT, CachedMsg> {
private: 
  using MyTable<CachedMsgT, CachedMsg>::MyTable;
  friend class MyFactory<CachedMsgM, CachedMsgT>;
  friend class MyFactory<CachedMsgM>;
public: 
  ~CachedMsgM() {}
  std::string get_auth_msg() {
    return native_table_ptr_->auth_msg;
  }
  bool set_auth_msg(std::string _auth_msg) {
    if( _auth_msg.length() > kMaxStringValLen ) {
        Revert("The string size is over limit.");
    }
    set_dirty(true);
    native_table_ptr_->auth_msg = std::move(_auth_msg);
    return true;
  }
};

struct AuthenticM : public MyTable<AuthenticT, Authentic> {
private: 
  using MyTable<AuthenticT, Authentic>::MyTable;
  friend class MyFactory<AuthenticM, AuthenticT>;
  friend class MyFactory<AuthenticM>;
public: 
  ~AuthenticM() {}
  bool get_holder() {
    return native_table_ptr_->holder;
  }
  bool set_holder(bool _holder) {
    set_dirty(true);
    native_table_ptr_->holder = _holder;
    return true;
  }
};

struct RelayerInfoM : public MyTable<RelayerInfoT, RelayerInfo> {
private: 
  using MyTable<RelayerInfoT, RelayerInfo>::MyTable;
  friend class MyFactory<RelayerInfoM, RelayerInfoT>;
  friend class MyFactory<RelayerInfoM>;
public: 
  ~RelayerInfoM() {}
  bool get_holder() {
    return native_table_ptr_->holder;
  }
  bool set_holder(bool _holder) {
    set_dirty(true);
    native_table_ptr_->holder = _holder;
    return true;
  }
};

struct RelayerIdentityM : public MyTable<RelayerIdentityT, RelayerIdentity> {
private: 
  using MyTable<RelayerIdentityT, RelayerIdentity>::MyTable;
  friend class MyFactory<RelayerIdentityM, RelayerIdentityT>;
  friend class MyFactory<RelayerIdentityM>;
public: 
  ~RelayerIdentityM() {}
  std::string get_relayer_id() {
    return native_table_ptr_->relayer_id;
  }
  bool set_relayer_id(std::string _relayer_id) {
    if( _relayer_id.length() > kMaxStringValLen ) {
        Revert("The string size is over limit.");
    }
    set_dirty(true);
    native_table_ptr_->relayer_id = std::move(_relayer_id);
    return true;
  }
};

struct ProtocolInfoM : public MyTable<ProtocolInfoT, ProtocolInfo> {
private: 
  using MyTable<ProtocolInfoT, ProtocolInfo>::MyTable;
  friend class MyFactory<ProtocolInfoM, ProtocolInfoT>;
  friend class MyFactory<ProtocolInfoM>;
public: 
  ~ProtocolInfoM() {}
  uint32_t get_protocol_type() {
    return native_table_ptr_->protocol_type;
  }
  bool set_protocol_type(uint32_t _protocol_type) {
    set_dirty(true);
    native_table_ptr_->protocol_type = _protocol_type;
    return true;
  }
};

struct RouteInfoM : public MyTable<RouteInfoT, RouteInfo> {
private: 
  using MyTable<RouteInfoT, RouteInfo>::MyTable;
  friend class MyFactory<RouteInfoM, RouteInfoT>;
  friend class MyFactory<RouteInfoM>;
public: 
  ~RouteInfoM() {}
  std::string get_protocol_id() {
    return native_table_ptr_->protocol_id;
  }
  bool set_protocol_id(std::string _protocol_id) {
    if( _protocol_id.length() > kMaxStringValLen ) {
        Revert("The string size is over limit.");
    }
    set_dirty(true);
    native_table_ptr_->protocol_id = std::move(_protocol_id);
    return true;
  }
};

struct DomainParseInfoM : public MyTable<DomainParseInfoT, DomainParseInfo> {
private: 
  using MyTable<DomainParseInfoT, DomainParseInfo>::MyTable;
  friend class MyFactory<DomainParseInfoM, DomainParseInfoT>;
  friend class MyFactory<DomainParseInfoM>;
public: 
  ~DomainParseInfoM() {}
  std::string get_contract_id() {
    return native_table_ptr_->contract_id;
  }
  bool set_contract_id(std::string _contract_id) {
    if( _contract_id.length() > kMaxStringValLen ) {
        Revert("The string size is over limit.");
    }
    set_dirty(true);
    native_table_ptr_->contract_id = std::move(_contract_id);
    return true;
  }
};

inline AuthMsgSchemaMPtr GetAuthMsgSchemaM() {
  static std::weak_ptr<AuthMsgSchemaM> wp;
  AuthMsgSchemaMPtr sp;
  sp = wp.lock();
  if (!sp) {
    std::string key = "root_contract_AuthMsgSchema";
    std::string buf;
    int ret = GetKV(key, buf);
    if(ret != 0) {
      return nullptr;
    }
    sp = MyFactory<AuthMsgSchemaM>::make_instance(buf, key /*, nullptr*/);
    wp = sp;
  }
  return sp;
}

int InitRoot() {
    std::string key = "root_contract_AuthMsgSchema";
    std::string buf;
    int ret = GetKV(key, buf);
    if(ret == 0) {
        Revert("MyBuffer has been already initialized.");
    }
    AuthMsgSchemaMPtr proot = MyFactory<AuthMsgSchemaM>::make_instance(key /*, nullptr*/);
    return 0;
}

}  // namespace AuthMsgSpace
}  // namespace Crosschain

#endif  // FLATBUFFERS_ANT_GENERATED_AUTHMESSAGE_CROSSCHAIN_AUTHMSGSPACE_H_
