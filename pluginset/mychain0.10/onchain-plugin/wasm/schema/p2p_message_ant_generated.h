// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_ANT_GENERATED_P2PMESSAGE_CROSSCHAIN_P2PMSGSPACE_H_
#define FLATBUFFERS_ANT_GENERATED_P2PMESSAGE_CROSSCHAIN_P2PMSGSPACE_H_

#include "flatbuffers/flatbuffers.h"
#include "mybuffer/mybuffer.h"
#include "p2p_message_generated.h"
#include <mychainlib/contract.h>
using namespace mychain;

namespace Crosschain {
namespace P2PMsgSpace {

struct P2PMsgSchemaM;
typedef flatbuffers::Offset<P2PMsgSchema> P2PMsgSchemaMOffset;
typedef std::shared_ptr<P2PMsgSchemaM> P2PMsgSchemaMPtr;
typedef std::shared_ptr<MyVector<P2PMsgSchemaM, P2PMsgSchemaT> > P2PMsgSchemaMVectorPtr;
typedef std::shared_ptr<MyMap<P2PMsgSchemaM> > P2PMsgSchemaMMapPtr;
typedef std::shared_ptr<MyMapIterable<P2PMsgSchemaM> > P2PMsgSchemaMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<P2PMsgSchemaM> > P2PMsgSchemaMMapKeyIterator;

struct AuthenticM;
typedef flatbuffers::Offset<Authentic> AuthenticMOffset;
typedef std::shared_ptr<AuthenticM> AuthenticMPtr;
typedef std::shared_ptr<MyVector<AuthenticM, AuthenticT> > AuthenticMVectorPtr;
typedef std::shared_ptr<MyMap<AuthenticM> > AuthenticMMapPtr;
typedef std::shared_ptr<MyMapIterable<AuthenticM> > AuthenticMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<AuthenticM> > AuthenticMMapKeyIterator;

struct SendContextM;
typedef flatbuffers::Offset<SendContext> SendContextMOffset;
typedef std::shared_ptr<SendContextM> SendContextMPtr;
typedef std::shared_ptr<MyVector<SendContextM, SendContextT> > SendContextMVectorPtr;
typedef std::shared_ptr<MyMap<SendContextM> > SendContextMMapPtr;
typedef std::shared_ptr<MyMapIterable<SendContextM> > SendContextMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<SendContextM> > SendContextMMapKeyIterator;

struct RecvContextM;
typedef flatbuffers::Offset<RecvContext> RecvContextMOffset;
typedef std::shared_ptr<RecvContextM> RecvContextMPtr;
typedef std::shared_ptr<MyVector<RecvContextM, RecvContextT> > RecvContextMVectorPtr;
typedef std::shared_ptr<MyMap<RecvContextM> > RecvContextMMapPtr;
typedef std::shared_ptr<MyMapIterable<RecvContextM> > RecvContextMMapIterablePtr;
typedef MapKeyIterator<MyMapIterable<RecvContextM> > RecvContextMMapKeyIterator;

struct P2PMsgSchemaM : public MyTable<P2PMsgSchemaT, P2PMsgSchema> {
private: 
  std::weak_ptr<MyMap<AuthenticM> > contract_admins_;
  std::weak_ptr<MyMap<SendContextM> > send_info_;
  std::weak_ptr<MyMap<RecvContextM> > recv_info_;
  using MyTable<P2PMsgSchemaT, P2PMsgSchema>::MyTable;
  friend class MyFactory<P2PMsgSchemaM, P2PMsgSchemaT>;
  friend class MyFactory<P2PMsgSchemaM>;
public: 
  ~P2PMsgSchemaM() {}
  AuthenticMMapPtr get_contract_admins() {
    AuthenticMMapPtr rv;
    rv = contract_admins_.lock();
    if (!rv) {
      rv = MyFactory<MyMap<AuthenticM> >::make_instance(ComposeKey(base_key_, "contract_admins"), get_self_ptr());
      contract_admins_ = rv;
    }
    return rv;
  }
  std::string get_am_contract() {
    return native_table_ptr_->am_contract;
  }
  bool set_am_contract(std::string _am_contract) {
    if( _am_contract.length() > kMaxStringValLen ) {
        Revert("The string size is over limit.");
    }
    set_dirty(true);
    native_table_ptr_->am_contract = std::move(_am_contract);
    return true;
  }
  std::string get_this_domain() {
    return native_table_ptr_->this_domain;
  }
  bool set_this_domain(std::string _this_domain) {
    if( _this_domain.length() > kMaxStringValLen ) {
        Revert("The string size is over limit.");
    }
    set_dirty(true);
    native_table_ptr_->this_domain = std::move(_this_domain);
    return true;
  }
  SendContextMMapPtr get_send_info() {
    SendContextMMapPtr rv;
    rv = send_info_.lock();
    if (!rv) {
      rv = MyFactory<MyMap<SendContextM> >::make_instance(ComposeKey(base_key_, "send_info"), get_self_ptr());
      send_info_ = rv;
    }
    return rv;
  }
  RecvContextMMapPtr get_recv_info() {
    RecvContextMMapPtr rv;
    rv = recv_info_.lock();
    if (!rv) {
      rv = MyFactory<MyMap<RecvContextM> >::make_instance(ComposeKey(base_key_, "recv_info"), get_self_ptr());
      recv_info_ = rv;
    }
    return rv;
  }
};

struct AuthenticM : public MyTable<AuthenticT, Authentic> {
private: 
  using MyTable<AuthenticT, Authentic>::MyTable;
  friend class MyFactory<AuthenticM, AuthenticT>;
  friend class MyFactory<AuthenticM>;
public: 
  ~AuthenticM() {}
  bool get_holder() {
    return native_table_ptr_->holder;
  }
  bool set_holder(bool _holder) {
    set_dirty(true);
    native_table_ptr_->holder = _holder;
    return true;
  }
};

struct SendContextM : public MyTable<SendContextT, SendContext> {
private: 
  using MyTable<SendContextT, SendContext>::MyTable;
  friend class MyFactory<SendContextM, SendContextT>;
  friend class MyFactory<SendContextM>;
public: 
  ~SendContextM() {}
  uint32_t get_sequence() {
    return native_table_ptr_->sequence;
  }
  bool set_sequence(uint32_t _sequence) {
    set_dirty(true);
    native_table_ptr_->sequence = _sequence;
    return true;
  }
};

struct RecvContextM : public MyTable<RecvContextT, RecvContext> {
private: 
  using MyTable<RecvContextT, RecvContext>::MyTable;
  friend class MyFactory<RecvContextM, RecvContextT>;
  friend class MyFactory<RecvContextM>;
public: 
  ~RecvContextM() {}
  uint32_t get_sequence() {
    return native_table_ptr_->sequence;
  }
  bool set_sequence(uint32_t _sequence) {
    set_dirty(true);
    native_table_ptr_->sequence = _sequence;
    return true;
  }
};

inline P2PMsgSchemaMPtr GetP2PMsgSchemaM() {
  static std::weak_ptr<P2PMsgSchemaM> wp;
  P2PMsgSchemaMPtr sp;
  sp = wp.lock();
  if (!sp) {
    std::string key = "root_contract_P2PMsgSchema";
    std::string buf;
    int ret = GetKV(key, buf);
    if(ret != 0) {
      return nullptr;
    }
    sp = MyFactory<P2PMsgSchemaM>::make_instance(buf, key /*, nullptr*/);
    wp = sp;
  }
  return sp;
}

int InitRoot() {
    std::string key = "root_contract_P2PMsgSchema";
    std::string buf;
    int ret = GetKV(key, buf);
    if(ret == 0) {
        Revert("MyBuffer has been already initialized.");
    }
    P2PMsgSchemaMPtr proot = MyFactory<P2PMsgSchemaM>::make_instance(key /*, nullptr*/);
    return 0;
}

}  // namespace P2PMsgSpace
}  // namespace Crosschain

#endif  // FLATBUFFERS_ANT_GENERATED_P2PMESSAGE_CROSSCHAIN_P2PMSGSPACE_H_
