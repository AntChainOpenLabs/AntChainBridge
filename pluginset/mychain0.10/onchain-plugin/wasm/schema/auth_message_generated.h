// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AUTHMESSAGE_CROSSCHAIN_AUTHMSGSPACE_H_
#define FLATBUFFERS_GENERATED_AUTHMESSAGE_CROSSCHAIN_AUTHMSGSPACE_H_

#include "flatbuffers/flatbuffers.h"

namespace Crosschain {
namespace AuthMsgSpace {

struct AuthMsgSchema;
struct AuthMsgSchemaT;

struct CachedMsg;
struct CachedMsgT;

struct Authentic;
struct AuthenticT;

struct RelayerInfo;
struct RelayerInfoT;

struct RelayerIdentity;
struct RelayerIdentityT;

struct ProtocolInfo;
struct ProtocolInfoT;

struct RouteInfo;
struct RouteInfoT;

struct DomainParseInfo;
struct DomainParseInfoT;

struct AuthMsgSchemaT : public flatbuffers::NativeTable {
  typedef AuthMsgSchema TableType;
  std::vector<std::unique_ptr<AuthenticT>> contract_admins;
  std::vector<std::unique_ptr<RelayerInfoT>> allowed_relayers;
  std::vector<std::unique_ptr<RelayerIdentityT>> relayer_list;
  std::vector<std::unique_ptr<ProtocolInfoT>> allowed_protocols;
  std::vector<std::unique_ptr<RouteInfoT>> protocol_routes;
  std::vector<std::unique_ptr<DomainParseInfoT>> domain_parse_info;
  std::string myoracle_contract;
  std::string myoracle_service;
  std::vector<std::unique_ptr<CachedMsgT>> cached_auth_msgs;
  AuthMsgSchemaT() {
  }
};

struct AuthMsgSchema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AuthMsgSchemaT NativeTableType;
  enum {
    VT_CONTRACT_ADMINS = 4,
    VT_ALLOWED_RELAYERS = 6,
    VT_RELAYER_LIST = 8,
    VT_ALLOWED_PROTOCOLS = 10,
    VT_PROTOCOL_ROUTES = 12,
    VT_DOMAIN_PARSE_INFO = 14,
    VT_MYORACLE_CONTRACT = 16,
    VT_MYORACLE_SERVICE = 18,
    VT_CACHED_AUTH_MSGS = 20
  };
  const flatbuffers::Vector<flatbuffers::Offset<Authentic>> *contract_admins() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Authentic>> *>(VT_CONTRACT_ADMINS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Authentic>> *mutable_contract_admins() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Authentic>> *>(VT_CONTRACT_ADMINS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RelayerInfo>> *allowed_relayers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RelayerInfo>> *>(VT_ALLOWED_RELAYERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<RelayerInfo>> *mutable_allowed_relayers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<RelayerInfo>> *>(VT_ALLOWED_RELAYERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RelayerIdentity>> *relayer_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RelayerIdentity>> *>(VT_RELAYER_LIST);
  }
  flatbuffers::Vector<flatbuffers::Offset<RelayerIdentity>> *mutable_relayer_list() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<RelayerIdentity>> *>(VT_RELAYER_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ProtocolInfo>> *allowed_protocols() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ProtocolInfo>> *>(VT_ALLOWED_PROTOCOLS);
  }
  flatbuffers::Vector<flatbuffers::Offset<ProtocolInfo>> *mutable_allowed_protocols() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ProtocolInfo>> *>(VT_ALLOWED_PROTOCOLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RouteInfo>> *protocol_routes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RouteInfo>> *>(VT_PROTOCOL_ROUTES);
  }
  flatbuffers::Vector<flatbuffers::Offset<RouteInfo>> *mutable_protocol_routes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<RouteInfo>> *>(VT_PROTOCOL_ROUTES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DomainParseInfo>> *domain_parse_info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DomainParseInfo>> *>(VT_DOMAIN_PARSE_INFO);
  }
  flatbuffers::Vector<flatbuffers::Offset<DomainParseInfo>> *mutable_domain_parse_info() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<DomainParseInfo>> *>(VT_DOMAIN_PARSE_INFO);
  }
  const flatbuffers::String *myoracle_contract() const {
    return GetPointer<const flatbuffers::String *>(VT_MYORACLE_CONTRACT);
  }
  flatbuffers::String *mutable_myoracle_contract() {
    return GetPointer<flatbuffers::String *>(VT_MYORACLE_CONTRACT);
  }
  const flatbuffers::String *myoracle_service() const {
    return GetPointer<const flatbuffers::String *>(VT_MYORACLE_SERVICE);
  }
  flatbuffers::String *mutable_myoracle_service() {
    return GetPointer<flatbuffers::String *>(VT_MYORACLE_SERVICE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CachedMsg>> *cached_auth_msgs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CachedMsg>> *>(VT_CACHED_AUTH_MSGS);
  }
  flatbuffers::Vector<flatbuffers::Offset<CachedMsg>> *mutable_cached_auth_msgs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<CachedMsg>> *>(VT_CACHED_AUTH_MSGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTRACT_ADMINS) &&
           verifier.VerifyVector(contract_admins()) &&
           verifier.VerifyVectorOfTables(contract_admins()) &&
           VerifyOffset(verifier, VT_ALLOWED_RELAYERS) &&
           verifier.VerifyVector(allowed_relayers()) &&
           verifier.VerifyVectorOfTables(allowed_relayers()) &&
           VerifyOffset(verifier, VT_RELAYER_LIST) &&
           verifier.VerifyVector(relayer_list()) &&
           verifier.VerifyVectorOfTables(relayer_list()) &&
           VerifyOffset(verifier, VT_ALLOWED_PROTOCOLS) &&
           verifier.VerifyVector(allowed_protocols()) &&
           verifier.VerifyVectorOfTables(allowed_protocols()) &&
           VerifyOffset(verifier, VT_PROTOCOL_ROUTES) &&
           verifier.VerifyVector(protocol_routes()) &&
           verifier.VerifyVectorOfTables(protocol_routes()) &&
           VerifyOffset(verifier, VT_DOMAIN_PARSE_INFO) &&
           verifier.VerifyVector(domain_parse_info()) &&
           verifier.VerifyVectorOfTables(domain_parse_info()) &&
           VerifyOffset(verifier, VT_MYORACLE_CONTRACT) &&
           verifier.VerifyString(myoracle_contract()) &&
           VerifyOffset(verifier, VT_MYORACLE_SERVICE) &&
           verifier.VerifyString(myoracle_service()) &&
           VerifyOffset(verifier, VT_CACHED_AUTH_MSGS) &&
           verifier.VerifyVector(cached_auth_msgs()) &&
           verifier.VerifyVectorOfTables(cached_auth_msgs()) &&
           verifier.EndTable();
  }
  AuthMsgSchemaT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthMsgSchemaT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AuthMsgSchema> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthMsgSchemaT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthMsgSchemaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contract_admins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Authentic>>> contract_admins) {
    fbb_.AddOffset(AuthMsgSchema::VT_CONTRACT_ADMINS, contract_admins);
  }
  void add_allowed_relayers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RelayerInfo>>> allowed_relayers) {
    fbb_.AddOffset(AuthMsgSchema::VT_ALLOWED_RELAYERS, allowed_relayers);
  }
  void add_relayer_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RelayerIdentity>>> relayer_list) {
    fbb_.AddOffset(AuthMsgSchema::VT_RELAYER_LIST, relayer_list);
  }
  void add_allowed_protocols(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProtocolInfo>>> allowed_protocols) {
    fbb_.AddOffset(AuthMsgSchema::VT_ALLOWED_PROTOCOLS, allowed_protocols);
  }
  void add_protocol_routes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RouteInfo>>> protocol_routes) {
    fbb_.AddOffset(AuthMsgSchema::VT_PROTOCOL_ROUTES, protocol_routes);
  }
  void add_domain_parse_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DomainParseInfo>>> domain_parse_info) {
    fbb_.AddOffset(AuthMsgSchema::VT_DOMAIN_PARSE_INFO, domain_parse_info);
  }
  void add_myoracle_contract(flatbuffers::Offset<flatbuffers::String> myoracle_contract) {
    fbb_.AddOffset(AuthMsgSchema::VT_MYORACLE_CONTRACT, myoracle_contract);
  }
  void add_myoracle_service(flatbuffers::Offset<flatbuffers::String> myoracle_service) {
    fbb_.AddOffset(AuthMsgSchema::VT_MYORACLE_SERVICE, myoracle_service);
  }
  void add_cached_auth_msgs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CachedMsg>>> cached_auth_msgs) {
    fbb_.AddOffset(AuthMsgSchema::VT_CACHED_AUTH_MSGS, cached_auth_msgs);
  }
  explicit AuthMsgSchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthMsgSchemaBuilder &operator=(const AuthMsgSchemaBuilder &);
  flatbuffers::Offset<AuthMsgSchema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AuthMsgSchema>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthMsgSchema> CreateAuthMsgSchema(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Authentic>>> contract_admins = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RelayerInfo>>> allowed_relayers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RelayerIdentity>>> relayer_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProtocolInfo>>> allowed_protocols = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RouteInfo>>> protocol_routes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DomainParseInfo>>> domain_parse_info = 0,
    flatbuffers::Offset<flatbuffers::String> myoracle_contract = 0,
    flatbuffers::Offset<flatbuffers::String> myoracle_service = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CachedMsg>>> cached_auth_msgs = 0) {
  AuthMsgSchemaBuilder builder_(_fbb);
  builder_.add_cached_auth_msgs(cached_auth_msgs);
  builder_.add_myoracle_service(myoracle_service);
  builder_.add_myoracle_contract(myoracle_contract);
  builder_.add_domain_parse_info(domain_parse_info);
  builder_.add_protocol_routes(protocol_routes);
  builder_.add_allowed_protocols(allowed_protocols);
  builder_.add_relayer_list(relayer_list);
  builder_.add_allowed_relayers(allowed_relayers);
  builder_.add_contract_admins(contract_admins);
  return builder_.Finish();
}

inline flatbuffers::Offset<AuthMsgSchema> CreateAuthMsgSchemaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Authentic>> *contract_admins = nullptr,
    const std::vector<flatbuffers::Offset<RelayerInfo>> *allowed_relayers = nullptr,
    const std::vector<flatbuffers::Offset<RelayerIdentity>> *relayer_list = nullptr,
    const std::vector<flatbuffers::Offset<ProtocolInfo>> *allowed_protocols = nullptr,
    const std::vector<flatbuffers::Offset<RouteInfo>> *protocol_routes = nullptr,
    const std::vector<flatbuffers::Offset<DomainParseInfo>> *domain_parse_info = nullptr,
    const char *myoracle_contract = nullptr,
    const char *myoracle_service = nullptr,
    const std::vector<flatbuffers::Offset<CachedMsg>> *cached_auth_msgs = nullptr) {
  return Crosschain::AuthMsgSpace::CreateAuthMsgSchema(
      _fbb,
      contract_admins ? _fbb.CreateVector<flatbuffers::Offset<Authentic>>(*contract_admins) : 0,
      allowed_relayers ? _fbb.CreateVector<flatbuffers::Offset<RelayerInfo>>(*allowed_relayers) : 0,
      relayer_list ? _fbb.CreateVector<flatbuffers::Offset<RelayerIdentity>>(*relayer_list) : 0,
      allowed_protocols ? _fbb.CreateVector<flatbuffers::Offset<ProtocolInfo>>(*allowed_protocols) : 0,
      protocol_routes ? _fbb.CreateVector<flatbuffers::Offset<RouteInfo>>(*protocol_routes) : 0,
      domain_parse_info ? _fbb.CreateVector<flatbuffers::Offset<DomainParseInfo>>(*domain_parse_info) : 0,
      myoracle_contract ? _fbb.CreateString(myoracle_contract) : 0,
      myoracle_service ? _fbb.CreateString(myoracle_service) : 0,
      cached_auth_msgs ? _fbb.CreateVector<flatbuffers::Offset<CachedMsg>>(*cached_auth_msgs) : 0);
}

flatbuffers::Offset<AuthMsgSchema> CreateAuthMsgSchema(flatbuffers::FlatBufferBuilder &_fbb, const AuthMsgSchemaT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CachedMsgT : public flatbuffers::NativeTable {
  typedef CachedMsg TableType;
  std::string auth_msg;
  CachedMsgT() {
  }
};

struct CachedMsg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CachedMsgT NativeTableType;
  enum {
    VT_AUTH_MSG = 4
  };
  const flatbuffers::String *auth_msg() const {
    return GetPointer<const flatbuffers::String *>(VT_AUTH_MSG);
  }
  flatbuffers::String *mutable_auth_msg() {
    return GetPointer<flatbuffers::String *>(VT_AUTH_MSG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AUTH_MSG) &&
           verifier.VerifyString(auth_msg()) &&
           verifier.EndTable();
  }
  CachedMsgT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CachedMsgT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CachedMsg> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CachedMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CachedMsgBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_auth_msg(flatbuffers::Offset<flatbuffers::String> auth_msg) {
    fbb_.AddOffset(CachedMsg::VT_AUTH_MSG, auth_msg);
  }
  explicit CachedMsgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CachedMsgBuilder &operator=(const CachedMsgBuilder &);
  flatbuffers::Offset<CachedMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CachedMsg>(end);
    return o;
  }
};

inline flatbuffers::Offset<CachedMsg> CreateCachedMsg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> auth_msg = 0) {
  CachedMsgBuilder builder_(_fbb);
  builder_.add_auth_msg(auth_msg);
  return builder_.Finish();
}

inline flatbuffers::Offset<CachedMsg> CreateCachedMsgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *auth_msg = nullptr) {
  return Crosschain::AuthMsgSpace::CreateCachedMsg(
      _fbb,
      auth_msg ? _fbb.CreateString(auth_msg) : 0);
}

flatbuffers::Offset<CachedMsg> CreateCachedMsg(flatbuffers::FlatBufferBuilder &_fbb, const CachedMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticT : public flatbuffers::NativeTable {
  typedef Authentic TableType;
  bool holder;
  AuthenticT()
      : holder(true) {
  }
};

struct Authentic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AuthenticT NativeTableType;
  enum {
    VT_HOLDER = 4
  };
  bool holder() const {
    return GetField<uint8_t>(VT_HOLDER, 1) != 0;
  }
  bool mutate_holder(bool _holder) {
    return SetField<uint8_t>(VT_HOLDER, static_cast<uint8_t>(_holder), 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HOLDER) &&
           verifier.EndTable();
  }
  AuthenticT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthenticT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Authentic> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthenticBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_holder(bool holder) {
    fbb_.AddElement<uint8_t>(Authentic::VT_HOLDER, static_cast<uint8_t>(holder), 1);
  }
  explicit AuthenticBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthenticBuilder &operator=(const AuthenticBuilder &);
  flatbuffers::Offset<Authentic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Authentic>(end);
    return o;
  }
};

inline flatbuffers::Offset<Authentic> CreateAuthentic(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool holder = true) {
  AuthenticBuilder builder_(_fbb);
  builder_.add_holder(holder);
  return builder_.Finish();
}

flatbuffers::Offset<Authentic> CreateAuthentic(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RelayerInfoT : public flatbuffers::NativeTable {
  typedef RelayerInfo TableType;
  bool holder;
  RelayerInfoT()
      : holder(true) {
  }
};

struct RelayerInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelayerInfoT NativeTableType;
  enum {
    VT_HOLDER = 4
  };
  bool holder() const {
    return GetField<uint8_t>(VT_HOLDER, 1) != 0;
  }
  bool mutate_holder(bool _holder) {
    return SetField<uint8_t>(VT_HOLDER, static_cast<uint8_t>(_holder), 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HOLDER) &&
           verifier.EndTable();
  }
  RelayerInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RelayerInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RelayerInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RelayerInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RelayerInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_holder(bool holder) {
    fbb_.AddElement<uint8_t>(RelayerInfo::VT_HOLDER, static_cast<uint8_t>(holder), 1);
  }
  explicit RelayerInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelayerInfoBuilder &operator=(const RelayerInfoBuilder &);
  flatbuffers::Offset<RelayerInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RelayerInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RelayerInfo> CreateRelayerInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool holder = true) {
  RelayerInfoBuilder builder_(_fbb);
  builder_.add_holder(holder);
  return builder_.Finish();
}

flatbuffers::Offset<RelayerInfo> CreateRelayerInfo(flatbuffers::FlatBufferBuilder &_fbb, const RelayerInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RelayerIdentityT : public flatbuffers::NativeTable {
  typedef RelayerIdentity TableType;
  std::string relayer_id;
  RelayerIdentityT() {
  }
};

struct RelayerIdentity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RelayerIdentityT NativeTableType;
  enum {
    VT_RELAYER_ID = 4
  };
  const flatbuffers::String *relayer_id() const {
    return GetPointer<const flatbuffers::String *>(VT_RELAYER_ID);
  }
  flatbuffers::String *mutable_relayer_id() {
    return GetPointer<flatbuffers::String *>(VT_RELAYER_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RELAYER_ID) &&
           verifier.VerifyString(relayer_id()) &&
           verifier.EndTable();
  }
  RelayerIdentityT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RelayerIdentityT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RelayerIdentity> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RelayerIdentityT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RelayerIdentityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_relayer_id(flatbuffers::Offset<flatbuffers::String> relayer_id) {
    fbb_.AddOffset(RelayerIdentity::VT_RELAYER_ID, relayer_id);
  }
  explicit RelayerIdentityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RelayerIdentityBuilder &operator=(const RelayerIdentityBuilder &);
  flatbuffers::Offset<RelayerIdentity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RelayerIdentity>(end);
    return o;
  }
};

inline flatbuffers::Offset<RelayerIdentity> CreateRelayerIdentity(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> relayer_id = 0) {
  RelayerIdentityBuilder builder_(_fbb);
  builder_.add_relayer_id(relayer_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<RelayerIdentity> CreateRelayerIdentityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *relayer_id = nullptr) {
  return Crosschain::AuthMsgSpace::CreateRelayerIdentity(
      _fbb,
      relayer_id ? _fbb.CreateString(relayer_id) : 0);
}

flatbuffers::Offset<RelayerIdentity> CreateRelayerIdentity(flatbuffers::FlatBufferBuilder &_fbb, const RelayerIdentityT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProtocolInfoT : public flatbuffers::NativeTable {
  typedef ProtocolInfo TableType;
  uint32_t protocol_type;
  ProtocolInfoT()
      : protocol_type(0) {
  }
};

struct ProtocolInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProtocolInfoT NativeTableType;
  enum {
    VT_PROTOCOL_TYPE = 4
  };
  uint32_t protocol_type() const {
    return GetField<uint32_t>(VT_PROTOCOL_TYPE, 0);
  }
  bool mutate_protocol_type(uint32_t _protocol_type) {
    return SetField<uint32_t>(VT_PROTOCOL_TYPE, _protocol_type, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PROTOCOL_TYPE) &&
           verifier.EndTable();
  }
  ProtocolInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProtocolInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProtocolInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProtocolInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProtocolInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_protocol_type(uint32_t protocol_type) {
    fbb_.AddElement<uint32_t>(ProtocolInfo::VT_PROTOCOL_TYPE, protocol_type, 0);
  }
  explicit ProtocolInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProtocolInfoBuilder &operator=(const ProtocolInfoBuilder &);
  flatbuffers::Offset<ProtocolInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProtocolInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProtocolInfo> CreateProtocolInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t protocol_type = 0) {
  ProtocolInfoBuilder builder_(_fbb);
  builder_.add_protocol_type(protocol_type);
  return builder_.Finish();
}

flatbuffers::Offset<ProtocolInfo> CreateProtocolInfo(flatbuffers::FlatBufferBuilder &_fbb, const ProtocolInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RouteInfoT : public flatbuffers::NativeTable {
  typedef RouteInfo TableType;
  std::string protocol_id;
  RouteInfoT() {
  }
};

struct RouteInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RouteInfoT NativeTableType;
  enum {
    VT_PROTOCOL_ID = 4
  };
  const flatbuffers::String *protocol_id() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL_ID);
  }
  flatbuffers::String *mutable_protocol_id() {
    return GetPointer<flatbuffers::String *>(VT_PROTOCOL_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROTOCOL_ID) &&
           verifier.VerifyString(protocol_id()) &&
           verifier.EndTable();
  }
  RouteInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RouteInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RouteInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RouteInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RouteInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_protocol_id(flatbuffers::Offset<flatbuffers::String> protocol_id) {
    fbb_.AddOffset(RouteInfo::VT_PROTOCOL_ID, protocol_id);
  }
  explicit RouteInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RouteInfoBuilder &operator=(const RouteInfoBuilder &);
  flatbuffers::Offset<RouteInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RouteInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<RouteInfo> CreateRouteInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> protocol_id = 0) {
  RouteInfoBuilder builder_(_fbb);
  builder_.add_protocol_id(protocol_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<RouteInfo> CreateRouteInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *protocol_id = nullptr) {
  return Crosschain::AuthMsgSpace::CreateRouteInfo(
      _fbb,
      protocol_id ? _fbb.CreateString(protocol_id) : 0);
}

flatbuffers::Offset<RouteInfo> CreateRouteInfo(flatbuffers::FlatBufferBuilder &_fbb, const RouteInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DomainParseInfoT : public flatbuffers::NativeTable {
  typedef DomainParseInfo TableType;
  std::string contract_id;
  DomainParseInfoT() {
  }
};

struct DomainParseInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DomainParseInfoT NativeTableType;
  enum {
    VT_CONTRACT_ID = 4
  };
  const flatbuffers::String *contract_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTRACT_ID);
  }
  flatbuffers::String *mutable_contract_id() {
    return GetPointer<flatbuffers::String *>(VT_CONTRACT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTRACT_ID) &&
           verifier.VerifyString(contract_id()) &&
           verifier.EndTable();
  }
  DomainParseInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DomainParseInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DomainParseInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DomainParseInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DomainParseInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contract_id(flatbuffers::Offset<flatbuffers::String> contract_id) {
    fbb_.AddOffset(DomainParseInfo::VT_CONTRACT_ID, contract_id);
  }
  explicit DomainParseInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DomainParseInfoBuilder &operator=(const DomainParseInfoBuilder &);
  flatbuffers::Offset<DomainParseInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DomainParseInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<DomainParseInfo> CreateDomainParseInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> contract_id = 0) {
  DomainParseInfoBuilder builder_(_fbb);
  builder_.add_contract_id(contract_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DomainParseInfo> CreateDomainParseInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *contract_id = nullptr) {
  return Crosschain::AuthMsgSpace::CreateDomainParseInfo(
      _fbb,
      contract_id ? _fbb.CreateString(contract_id) : 0);
}

flatbuffers::Offset<DomainParseInfo> CreateDomainParseInfo(flatbuffers::FlatBufferBuilder &_fbb, const DomainParseInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AuthMsgSchemaT *AuthMsgSchema::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AuthMsgSchemaT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AuthMsgSchema::UnPackTo(AuthMsgSchemaT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = contract_admins(); if (_e) { _o->contract_admins.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->contract_admins[_i] = std::unique_ptr<AuthenticT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = allowed_relayers(); if (_e) { _o->allowed_relayers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->allowed_relayers[_i] = std::unique_ptr<RelayerInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = relayer_list(); if (_e) { _o->relayer_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->relayer_list[_i] = std::unique_ptr<RelayerIdentityT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = allowed_protocols(); if (_e) { _o->allowed_protocols.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->allowed_protocols[_i] = std::unique_ptr<ProtocolInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = protocol_routes(); if (_e) { _o->protocol_routes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->protocol_routes[_i] = std::unique_ptr<RouteInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = domain_parse_info(); if (_e) { _o->domain_parse_info.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->domain_parse_info[_i] = std::unique_ptr<DomainParseInfoT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = myoracle_contract(); if (_e) _o->myoracle_contract = _e->str(); };
  { auto _e = myoracle_service(); if (_e) _o->myoracle_service = _e->str(); };
  { auto _e = cached_auth_msgs(); if (_e) { _o->cached_auth_msgs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cached_auth_msgs[_i] = std::unique_ptr<CachedMsgT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<AuthMsgSchema> AuthMsgSchema::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthMsgSchemaT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthMsgSchema(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AuthMsgSchema> CreateAuthMsgSchema(flatbuffers::FlatBufferBuilder &_fbb, const AuthMsgSchemaT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AuthMsgSchemaT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _contract_admins = _o->contract_admins.size() ? _fbb.CreateVector<flatbuffers::Offset<Authentic>> (_o->contract_admins.size(), [](size_t i, _VectorArgs *__va) { return CreateAuthentic(*__va->__fbb, __va->__o->contract_admins[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _allowed_relayers = _o->allowed_relayers.size() ? _fbb.CreateVector<flatbuffers::Offset<RelayerInfo>> (_o->allowed_relayers.size(), [](size_t i, _VectorArgs *__va) { return CreateRelayerInfo(*__va->__fbb, __va->__o->allowed_relayers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _relayer_list = _o->relayer_list.size() ? _fbb.CreateVector<flatbuffers::Offset<RelayerIdentity>> (_o->relayer_list.size(), [](size_t i, _VectorArgs *__va) { return CreateRelayerIdentity(*__va->__fbb, __va->__o->relayer_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _allowed_protocols = _o->allowed_protocols.size() ? _fbb.CreateVector<flatbuffers::Offset<ProtocolInfo>> (_o->allowed_protocols.size(), [](size_t i, _VectorArgs *__va) { return CreateProtocolInfo(*__va->__fbb, __va->__o->allowed_protocols[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _protocol_routes = _o->protocol_routes.size() ? _fbb.CreateVector<flatbuffers::Offset<RouteInfo>> (_o->protocol_routes.size(), [](size_t i, _VectorArgs *__va) { return CreateRouteInfo(*__va->__fbb, __va->__o->protocol_routes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _domain_parse_info = _o->domain_parse_info.size() ? _fbb.CreateVector<flatbuffers::Offset<DomainParseInfo>> (_o->domain_parse_info.size(), [](size_t i, _VectorArgs *__va) { return CreateDomainParseInfo(*__va->__fbb, __va->__o->domain_parse_info[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _myoracle_contract = _o->myoracle_contract.empty() ? 0 : _fbb.CreateString(_o->myoracle_contract);
  auto _myoracle_service = _o->myoracle_service.empty() ? 0 : _fbb.CreateString(_o->myoracle_service);
  auto _cached_auth_msgs = _o->cached_auth_msgs.size() ? _fbb.CreateVector<flatbuffers::Offset<CachedMsg>> (_o->cached_auth_msgs.size(), [](size_t i, _VectorArgs *__va) { return CreateCachedMsg(*__va->__fbb, __va->__o->cached_auth_msgs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Crosschain::AuthMsgSpace::CreateAuthMsgSchema(
      _fbb,
      _contract_admins,
      _allowed_relayers,
      _relayer_list,
      _allowed_protocols,
      _protocol_routes,
      _domain_parse_info,
      _myoracle_contract,
      _myoracle_service,
      _cached_auth_msgs);
}

inline CachedMsgT *CachedMsg::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CachedMsgT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CachedMsg::UnPackTo(CachedMsgT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = auth_msg(); if (_e) _o->auth_msg = _e->str(); };
}

inline flatbuffers::Offset<CachedMsg> CachedMsg::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CachedMsgT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCachedMsg(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CachedMsg> CreateCachedMsg(flatbuffers::FlatBufferBuilder &_fbb, const CachedMsgT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CachedMsgT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _auth_msg = _o->auth_msg.empty() ? 0 : _fbb.CreateString(_o->auth_msg);
  return Crosschain::AuthMsgSpace::CreateCachedMsg(
      _fbb,
      _auth_msg);
}

inline AuthenticT *Authentic::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AuthenticT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Authentic::UnPackTo(AuthenticT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = holder(); _o->holder = _e; };
}

inline flatbuffers::Offset<Authentic> Authentic::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthentic(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Authentic> CreateAuthentic(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AuthenticT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _holder = _o->holder;
  return Crosschain::AuthMsgSpace::CreateAuthentic(
      _fbb,
      _holder);
}

inline RelayerInfoT *RelayerInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RelayerInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RelayerInfo::UnPackTo(RelayerInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = holder(); _o->holder = _e; };
}

inline flatbuffers::Offset<RelayerInfo> RelayerInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RelayerInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelayerInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RelayerInfo> CreateRelayerInfo(flatbuffers::FlatBufferBuilder &_fbb, const RelayerInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RelayerInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _holder = _o->holder;
  return Crosschain::AuthMsgSpace::CreateRelayerInfo(
      _fbb,
      _holder);
}

inline RelayerIdentityT *RelayerIdentity::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RelayerIdentityT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RelayerIdentity::UnPackTo(RelayerIdentityT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = relayer_id(); if (_e) _o->relayer_id = _e->str(); };
}

inline flatbuffers::Offset<RelayerIdentity> RelayerIdentity::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RelayerIdentityT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRelayerIdentity(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RelayerIdentity> CreateRelayerIdentity(flatbuffers::FlatBufferBuilder &_fbb, const RelayerIdentityT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RelayerIdentityT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _relayer_id = _o->relayer_id.empty() ? 0 : _fbb.CreateString(_o->relayer_id);
  return Crosschain::AuthMsgSpace::CreateRelayerIdentity(
      _fbb,
      _relayer_id);
}

inline ProtocolInfoT *ProtocolInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProtocolInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ProtocolInfo::UnPackTo(ProtocolInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = protocol_type(); _o->protocol_type = _e; };
}

inline flatbuffers::Offset<ProtocolInfo> ProtocolInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProtocolInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProtocolInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProtocolInfo> CreateProtocolInfo(flatbuffers::FlatBufferBuilder &_fbb, const ProtocolInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProtocolInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _protocol_type = _o->protocol_type;
  return Crosschain::AuthMsgSpace::CreateProtocolInfo(
      _fbb,
      _protocol_type);
}

inline RouteInfoT *RouteInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RouteInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RouteInfo::UnPackTo(RouteInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = protocol_id(); if (_e) _o->protocol_id = _e->str(); };
}

inline flatbuffers::Offset<RouteInfo> RouteInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RouteInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRouteInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RouteInfo> CreateRouteInfo(flatbuffers::FlatBufferBuilder &_fbb, const RouteInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RouteInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _protocol_id = _o->protocol_id.empty() ? 0 : _fbb.CreateString(_o->protocol_id);
  return Crosschain::AuthMsgSpace::CreateRouteInfo(
      _fbb,
      _protocol_id);
}

inline DomainParseInfoT *DomainParseInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DomainParseInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DomainParseInfo::UnPackTo(DomainParseInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = contract_id(); if (_e) _o->contract_id = _e->str(); };
}

inline flatbuffers::Offset<DomainParseInfo> DomainParseInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DomainParseInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDomainParseInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DomainParseInfo> CreateDomainParseInfo(flatbuffers::FlatBufferBuilder &_fbb, const DomainParseInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DomainParseInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _contract_id = _o->contract_id.empty() ? 0 : _fbb.CreateString(_o->contract_id);
  return Crosschain::AuthMsgSpace::CreateDomainParseInfo(
      _fbb,
      _contract_id);
}

inline const Crosschain::AuthMsgSpace::AuthMsgSchema *GetAuthMsgSchema(const void *buf) {
  return flatbuffers::GetRoot<Crosschain::AuthMsgSpace::AuthMsgSchema>(buf);
}

inline const Crosschain::AuthMsgSpace::AuthMsgSchema *GetSizePrefixedAuthMsgSchema(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Crosschain::AuthMsgSpace::AuthMsgSchema>(buf);
}

inline AuthMsgSchema *GetMutableAuthMsgSchema(void *buf) {
  return flatbuffers::GetMutableRoot<AuthMsgSchema>(buf);
}

inline bool VerifyAuthMsgSchemaBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Crosschain::AuthMsgSpace::AuthMsgSchema>(nullptr);
}

inline bool VerifySizePrefixedAuthMsgSchemaBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Crosschain::AuthMsgSpace::AuthMsgSchema>(nullptr);
}

inline void FinishAuthMsgSchemaBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Crosschain::AuthMsgSpace::AuthMsgSchema> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedAuthMsgSchemaBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Crosschain::AuthMsgSpace::AuthMsgSchema> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<AuthMsgSchemaT> UnPackAuthMsgSchema(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<AuthMsgSchemaT>(GetAuthMsgSchema(buf)->UnPack(res));
}

}  // namespace AuthMsgSpace
}  // namespace Crosschain

#endif  // FLATBUFFERS_GENERATED_AUTHMESSAGE_CROSSCHAIN_AUTHMSGSPACE_H_
