// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_P2PMESSAGE_CROSSCHAIN_P2PMSGSPACE_H_
#define FLATBUFFERS_GENERATED_P2PMESSAGE_CROSSCHAIN_P2PMSGSPACE_H_

#include "flatbuffers/flatbuffers.h"

namespace Crosschain {
namespace P2PMsgSpace {

struct P2PMsgSchema;
struct P2PMsgSchemaT;

struct Authentic;
struct AuthenticT;

struct SendContext;
struct SendContextT;

struct RecvContext;
struct RecvContextT;

struct P2PMsgSchemaT : public flatbuffers::NativeTable {
  typedef P2PMsgSchema TableType;
  std::vector<std::unique_ptr<AuthenticT>> contract_admins;
  std::string am_contract;
  std::string this_domain;
  std::vector<std::unique_ptr<SendContextT>> send_info;
  std::vector<std::unique_ptr<RecvContextT>> recv_info;
  P2PMsgSchemaT() {
  }
};

struct P2PMsgSchema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef P2PMsgSchemaT NativeTableType;
  enum {
    VT_CONTRACT_ADMINS = 4,
    VT_AM_CONTRACT = 6,
    VT_THIS_DOMAIN = 8,
    VT_SEND_INFO = 10,
    VT_RECV_INFO = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<Authentic>> *contract_admins() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Authentic>> *>(VT_CONTRACT_ADMINS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Authentic>> *mutable_contract_admins() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Authentic>> *>(VT_CONTRACT_ADMINS);
  }
  const flatbuffers::String *am_contract() const {
    return GetPointer<const flatbuffers::String *>(VT_AM_CONTRACT);
  }
  flatbuffers::String *mutable_am_contract() {
    return GetPointer<flatbuffers::String *>(VT_AM_CONTRACT);
  }
  const flatbuffers::String *this_domain() const {
    return GetPointer<const flatbuffers::String *>(VT_THIS_DOMAIN);
  }
  flatbuffers::String *mutable_this_domain() {
    return GetPointer<flatbuffers::String *>(VT_THIS_DOMAIN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SendContext>> *send_info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SendContext>> *>(VT_SEND_INFO);
  }
  flatbuffers::Vector<flatbuffers::Offset<SendContext>> *mutable_send_info() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<SendContext>> *>(VT_SEND_INFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RecvContext>> *recv_info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RecvContext>> *>(VT_RECV_INFO);
  }
  flatbuffers::Vector<flatbuffers::Offset<RecvContext>> *mutable_recv_info() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<RecvContext>> *>(VT_RECV_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTRACT_ADMINS) &&
           verifier.VerifyVector(contract_admins()) &&
           verifier.VerifyVectorOfTables(contract_admins()) &&
           VerifyOffset(verifier, VT_AM_CONTRACT) &&
           verifier.VerifyString(am_contract()) &&
           VerifyOffset(verifier, VT_THIS_DOMAIN) &&
           verifier.VerifyString(this_domain()) &&
           VerifyOffset(verifier, VT_SEND_INFO) &&
           verifier.VerifyVector(send_info()) &&
           verifier.VerifyVectorOfTables(send_info()) &&
           VerifyOffset(verifier, VT_RECV_INFO) &&
           verifier.VerifyVector(recv_info()) &&
           verifier.VerifyVectorOfTables(recv_info()) &&
           verifier.EndTable();
  }
  P2PMsgSchemaT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(P2PMsgSchemaT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<P2PMsgSchema> Pack(flatbuffers::FlatBufferBuilder &_fbb, const P2PMsgSchemaT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct P2PMsgSchemaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contract_admins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Authentic>>> contract_admins) {
    fbb_.AddOffset(P2PMsgSchema::VT_CONTRACT_ADMINS, contract_admins);
  }
  void add_am_contract(flatbuffers::Offset<flatbuffers::String> am_contract) {
    fbb_.AddOffset(P2PMsgSchema::VT_AM_CONTRACT, am_contract);
  }
  void add_this_domain(flatbuffers::Offset<flatbuffers::String> this_domain) {
    fbb_.AddOffset(P2PMsgSchema::VT_THIS_DOMAIN, this_domain);
  }
  void add_send_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SendContext>>> send_info) {
    fbb_.AddOffset(P2PMsgSchema::VT_SEND_INFO, send_info);
  }
  void add_recv_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RecvContext>>> recv_info) {
    fbb_.AddOffset(P2PMsgSchema::VT_RECV_INFO, recv_info);
  }
  explicit P2PMsgSchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  P2PMsgSchemaBuilder &operator=(const P2PMsgSchemaBuilder &);
  flatbuffers::Offset<P2PMsgSchema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<P2PMsgSchema>(end);
    return o;
  }
};

inline flatbuffers::Offset<P2PMsgSchema> CreateP2PMsgSchema(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Authentic>>> contract_admins = 0,
    flatbuffers::Offset<flatbuffers::String> am_contract = 0,
    flatbuffers::Offset<flatbuffers::String> this_domain = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SendContext>>> send_info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RecvContext>>> recv_info = 0) {
  P2PMsgSchemaBuilder builder_(_fbb);
  builder_.add_recv_info(recv_info);
  builder_.add_send_info(send_info);
  builder_.add_this_domain(this_domain);
  builder_.add_am_contract(am_contract);
  builder_.add_contract_admins(contract_admins);
  return builder_.Finish();
}

inline flatbuffers::Offset<P2PMsgSchema> CreateP2PMsgSchemaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Authentic>> *contract_admins = nullptr,
    const char *am_contract = nullptr,
    const char *this_domain = nullptr,
    const std::vector<flatbuffers::Offset<SendContext>> *send_info = nullptr,
    const std::vector<flatbuffers::Offset<RecvContext>> *recv_info = nullptr) {
  return Crosschain::P2PMsgSpace::CreateP2PMsgSchema(
      _fbb,
      contract_admins ? _fbb.CreateVector<flatbuffers::Offset<Authentic>>(*contract_admins) : 0,
      am_contract ? _fbb.CreateString(am_contract) : 0,
      this_domain ? _fbb.CreateString(this_domain) : 0,
      send_info ? _fbb.CreateVector<flatbuffers::Offset<SendContext>>(*send_info) : 0,
      recv_info ? _fbb.CreateVector<flatbuffers::Offset<RecvContext>>(*recv_info) : 0);
}

flatbuffers::Offset<P2PMsgSchema> CreateP2PMsgSchema(flatbuffers::FlatBufferBuilder &_fbb, const P2PMsgSchemaT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticT : public flatbuffers::NativeTable {
  typedef Authentic TableType;
  bool holder;
  AuthenticT()
      : holder(true) {
  }
};

struct Authentic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AuthenticT NativeTableType;
  enum {
    VT_HOLDER = 4
  };
  bool holder() const {
    return GetField<uint8_t>(VT_HOLDER, 1) != 0;
  }
  bool mutate_holder(bool _holder) {
    return SetField<uint8_t>(VT_HOLDER, static_cast<uint8_t>(_holder), 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HOLDER) &&
           verifier.EndTable();
  }
  AuthenticT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthenticT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Authentic> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthenticBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_holder(bool holder) {
    fbb_.AddElement<uint8_t>(Authentic::VT_HOLDER, static_cast<uint8_t>(holder), 1);
  }
  explicit AuthenticBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthenticBuilder &operator=(const AuthenticBuilder &);
  flatbuffers::Offset<Authentic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Authentic>(end);
    return o;
  }
};

inline flatbuffers::Offset<Authentic> CreateAuthentic(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool holder = true) {
  AuthenticBuilder builder_(_fbb);
  builder_.add_holder(holder);
  return builder_.Finish();
}

flatbuffers::Offset<Authentic> CreateAuthentic(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SendContextT : public flatbuffers::NativeTable {
  typedef SendContext TableType;
  uint32_t sequence;
  SendContextT()
      : sequence(0) {
  }
};

struct SendContext FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SendContextT NativeTableType;
  enum {
    VT_SEQUENCE = 4
  };
  uint32_t sequence() const {
    return GetField<uint32_t>(VT_SEQUENCE, 0);
  }
  bool mutate_sequence(uint32_t _sequence) {
    return SetField<uint32_t>(VT_SEQUENCE, _sequence, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE) &&
           verifier.EndTable();
  }
  SendContextT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SendContextT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SendContext> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SendContextT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SendContextBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sequence(uint32_t sequence) {
    fbb_.AddElement<uint32_t>(SendContext::VT_SEQUENCE, sequence, 0);
  }
  explicit SendContextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SendContextBuilder &operator=(const SendContextBuilder &);
  flatbuffers::Offset<SendContext> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SendContext>(end);
    return o;
  }
};

inline flatbuffers::Offset<SendContext> CreateSendContext(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sequence = 0) {
  SendContextBuilder builder_(_fbb);
  builder_.add_sequence(sequence);
  return builder_.Finish();
}

flatbuffers::Offset<SendContext> CreateSendContext(flatbuffers::FlatBufferBuilder &_fbb, const SendContextT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RecvContextT : public flatbuffers::NativeTable {
  typedef RecvContext TableType;
  uint32_t sequence;
  RecvContextT()
      : sequence(0) {
  }
};

struct RecvContext FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecvContextT NativeTableType;
  enum {
    VT_SEQUENCE = 4
  };
  uint32_t sequence() const {
    return GetField<uint32_t>(VT_SEQUENCE, 0);
  }
  bool mutate_sequence(uint32_t _sequence) {
    return SetField<uint32_t>(VT_SEQUENCE, _sequence, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE) &&
           verifier.EndTable();
  }
  RecvContextT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RecvContextT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RecvContext> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RecvContextT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RecvContextBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sequence(uint32_t sequence) {
    fbb_.AddElement<uint32_t>(RecvContext::VT_SEQUENCE, sequence, 0);
  }
  explicit RecvContextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecvContextBuilder &operator=(const RecvContextBuilder &);
  flatbuffers::Offset<RecvContext> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecvContext>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecvContext> CreateRecvContext(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sequence = 0) {
  RecvContextBuilder builder_(_fbb);
  builder_.add_sequence(sequence);
  return builder_.Finish();
}

flatbuffers::Offset<RecvContext> CreateRecvContext(flatbuffers::FlatBufferBuilder &_fbb, const RecvContextT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline P2PMsgSchemaT *P2PMsgSchema::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new P2PMsgSchemaT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void P2PMsgSchema::UnPackTo(P2PMsgSchemaT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = contract_admins(); if (_e) { _o->contract_admins.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->contract_admins[_i] = std::unique_ptr<AuthenticT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = am_contract(); if (_e) _o->am_contract = _e->str(); };
  { auto _e = this_domain(); if (_e) _o->this_domain = _e->str(); };
  { auto _e = send_info(); if (_e) { _o->send_info.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->send_info[_i] = std::unique_ptr<SendContextT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = recv_info(); if (_e) { _o->recv_info.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->recv_info[_i] = std::unique_ptr<RecvContextT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<P2PMsgSchema> P2PMsgSchema::Pack(flatbuffers::FlatBufferBuilder &_fbb, const P2PMsgSchemaT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateP2PMsgSchema(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<P2PMsgSchema> CreateP2PMsgSchema(flatbuffers::FlatBufferBuilder &_fbb, const P2PMsgSchemaT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const P2PMsgSchemaT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _contract_admins = _o->contract_admins.size() ? _fbb.CreateVector<flatbuffers::Offset<Authentic>> (_o->contract_admins.size(), [](size_t i, _VectorArgs *__va) { return CreateAuthentic(*__va->__fbb, __va->__o->contract_admins[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _am_contract = _o->am_contract.empty() ? 0 : _fbb.CreateString(_o->am_contract);
  auto _this_domain = _o->this_domain.empty() ? 0 : _fbb.CreateString(_o->this_domain);
  auto _send_info = _o->send_info.size() ? _fbb.CreateVector<flatbuffers::Offset<SendContext>> (_o->send_info.size(), [](size_t i, _VectorArgs *__va) { return CreateSendContext(*__va->__fbb, __va->__o->send_info[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _recv_info = _o->recv_info.size() ? _fbb.CreateVector<flatbuffers::Offset<RecvContext>> (_o->recv_info.size(), [](size_t i, _VectorArgs *__va) { return CreateRecvContext(*__va->__fbb, __va->__o->recv_info[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Crosschain::P2PMsgSpace::CreateP2PMsgSchema(
      _fbb,
      _contract_admins,
      _am_contract,
      _this_domain,
      _send_info,
      _recv_info);
}

inline AuthenticT *Authentic::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AuthenticT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Authentic::UnPackTo(AuthenticT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = holder(); _o->holder = _e; };
}

inline flatbuffers::Offset<Authentic> Authentic::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthentic(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Authentic> CreateAuthentic(flatbuffers::FlatBufferBuilder &_fbb, const AuthenticT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AuthenticT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _holder = _o->holder;
  return Crosschain::P2PMsgSpace::CreateAuthentic(
      _fbb,
      _holder);
}

inline SendContextT *SendContext::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SendContextT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SendContext::UnPackTo(SendContextT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sequence(); _o->sequence = _e; };
}

inline flatbuffers::Offset<SendContext> SendContext::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SendContextT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSendContext(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SendContext> CreateSendContext(flatbuffers::FlatBufferBuilder &_fbb, const SendContextT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SendContextT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sequence = _o->sequence;
  return Crosschain::P2PMsgSpace::CreateSendContext(
      _fbb,
      _sequence);
}

inline RecvContextT *RecvContext::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RecvContextT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RecvContext::UnPackTo(RecvContextT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sequence(); _o->sequence = _e; };
}

inline flatbuffers::Offset<RecvContext> RecvContext::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RecvContextT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRecvContext(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RecvContext> CreateRecvContext(flatbuffers::FlatBufferBuilder &_fbb, const RecvContextT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RecvContextT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sequence = _o->sequence;
  return Crosschain::P2PMsgSpace::CreateRecvContext(
      _fbb,
      _sequence);
}

inline const Crosschain::P2PMsgSpace::P2PMsgSchema *GetP2PMsgSchema(const void *buf) {
  return flatbuffers::GetRoot<Crosschain::P2PMsgSpace::P2PMsgSchema>(buf);
}

inline const Crosschain::P2PMsgSpace::P2PMsgSchema *GetSizePrefixedP2PMsgSchema(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Crosschain::P2PMsgSpace::P2PMsgSchema>(buf);
}

inline P2PMsgSchema *GetMutableP2PMsgSchema(void *buf) {
  return flatbuffers::GetMutableRoot<P2PMsgSchema>(buf);
}

inline bool VerifyP2PMsgSchemaBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Crosschain::P2PMsgSpace::P2PMsgSchema>(nullptr);
}

inline bool VerifySizePrefixedP2PMsgSchemaBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Crosschain::P2PMsgSpace::P2PMsgSchema>(nullptr);
}

inline void FinishP2PMsgSchemaBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Crosschain::P2PMsgSpace::P2PMsgSchema> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedP2PMsgSchemaBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Crosschain::P2PMsgSpace::P2PMsgSchema> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<P2PMsgSchemaT> UnPackP2PMsgSchema(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<P2PMsgSchemaT>(GetP2PMsgSchema(buf)->UnPack(res));
}

}  // namespace P2PMsgSpace
}  // namespace Crosschain

#endif  // FLATBUFFERS_GENERATED_P2PMESSAGE_CROSSCHAIN_P2PMSGSPACE_H_
